
<!doctype html>
<html lang="en">

<head>
    <title>Code coverage report for docs/assets/main.js</title>
    <meta charset="utf-8" />
    <link rel="stylesheet" href="../../prettify.css" />
    <link rel="stylesheet" href="../../base.css" />
    <link rel="shortcut icon" type="image/x-icon" href="../../favicon.png" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style type='text/css'>
        .coverage-summary .sorter {
            background-image: url(../../sort-arrow-sprite.png);
        }
    </style>
</head>
    
<body>
<div class='wrapper'>
    <div class='pad1'>
        <h1><a href="../../index.html">All files</a> / <a href="index.html">docs/assets</a> main.js</h1>
        <div class='clearfix'>
            
            <div class='fl pad1y space-right2'>
                <span class="strong">0% </span>
                <span class="quiet">Statements</span>
                <span class='fraction'>0/1085</span>
            </div>
        
            
            <div class='fl pad1y space-right2'>
                <span class="strong">0% </span>
                <span class="quiet">Branches</span>
                <span class='fraction'>0/635</span>
            </div>
        
            
            <div class='fl pad1y space-right2'>
                <span class="strong">0% </span>
                <span class="quiet">Functions</span>
                <span class='fraction'>0/240</span>
            </div>
        
            
            <div class='fl pad1y space-right2'>
                <span class="strong">0% </span>
                <span class="quiet">Lines</span>
                <span class='fraction'>0/2</span>
            </div>
        
            
        </div>
        <p class="quiet">
            Press <em>n</em> or <em>j</em> to go to the next uncovered block, <em>b</em>, <em>p</em> or <em>k</em> for the previous block.
        </p>
    </div>
    <div class='status-line low'></div>
    <pre><table class="coverage">
<tr><td class="line-count quiet"><a name='L1'></a><a href='#L1'>1</a>
<a name='L2'></a><a href='#L2'>2</a>
<a name='L3'></a><a href='#L3'>3</a>
<a name='L4'></a><a href='#L4'>4</a>
<a name='L5'></a><a href='#L5'>5</a>
<a name='L6'></a><a href='#L6'>6</a>
<a name='L7'></a><a href='#L7'>7</a>
<a name='L8'></a><a href='#L8'>8</a>
<a name='L9'></a><a href='#L9'>9</a>
<a name='L10'></a><a href='#L10'>10</a>
<a name='L11'></a><a href='#L11'>11</a>
<a name='L12'></a><a href='#L12'>12</a>
<a name='L13'></a><a href='#L13'>13</a>
<a name='L14'></a><a href='#L14'>14</a>
<a name='L15'></a><a href='#L15'>15</a>
<a name='L16'></a><a href='#L16'>16</a>
<a name='L17'></a><a href='#L17'>17</a>
<a name='L18'></a><a href='#L18'>18</a>
<a name='L19'></a><a href='#L19'>19</a>
<a name='L20'></a><a href='#L20'>20</a>
<a name='L21'></a><a href='#L21'>21</a>
<a name='L22'></a><a href='#L22'>22</a>
<a name='L23'></a><a href='#L23'>23</a>
<a name='L24'></a><a href='#L24'>24</a>
<a name='L25'></a><a href='#L25'>25</a>
<a name='L26'></a><a href='#L26'>26</a>
<a name='L27'></a><a href='#L27'>27</a>
<a name='L28'></a><a href='#L28'>28</a>
<a name='L29'></a><a href='#L29'>29</a>
<a name='L30'></a><a href='#L30'>30</a>
<a name='L31'></a><a href='#L31'>31</a>
<a name='L32'></a><a href='#L32'>32</a>
<a name='L33'></a><a href='#L33'>33</a>
<a name='L34'></a><a href='#L34'>34</a>
<a name='L35'></a><a href='#L35'>35</a>
<a name='L36'></a><a href='#L36'>36</a>
<a name='L37'></a><a href='#L37'>37</a>
<a name='L38'></a><a href='#L38'>38</a>
<a name='L39'></a><a href='#L39'>39</a>
<a name='L40'></a><a href='#L40'>40</a>
<a name='L41'></a><a href='#L41'>41</a>
<a name='L42'></a><a href='#L42'>42</a>
<a name='L43'></a><a href='#L43'>43</a>
<a name='L44'></a><a href='#L44'>44</a>
<a name='L45'></a><a href='#L45'>45</a>
<a name='L46'></a><a href='#L46'>46</a>
<a name='L47'></a><a href='#L47'>47</a>
<a name='L48'></a><a href='#L48'>48</a>
<a name='L49'></a><a href='#L49'>49</a>
<a name='L50'></a><a href='#L50'>50</a>
<a name='L51'></a><a href='#L51'>51</a>
<a name='L52'></a><a href='#L52'>52</a>
<a name='L53'></a><a href='#L53'>53</a></td><td class="line-coverage quiet"><span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span></td><td class="text"><pre class="prettyprint lang-js"><span class="cstat-no" title="statement not covered" >(<span class="fstat-no" title="function not covered" >()</span>=&gt;{var Ce=<span class="cstat-no" title="statement not covered" >Object.create;</span>var ue=<span class="cstat-no" title="statement not covered" >Object.defineProperty;</span>var Pe=<span class="cstat-no" title="statement not covered" >Object.getOwnPropertyDescriptor;</span>var Oe=<span class="cstat-no" title="statement not covered" >Object.getOwnPropertyNames;</span>var Re=<span class="cstat-no" title="statement not covered" >Object.getPrototypeOf,</span>_e=<span class="cstat-no" title="statement not covered" >Object.prototype.hasOwnProperty;</span>var Me=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;(<span class="cstat-no" title="statement not covered" >e||t((e={exports:{}}).exports,e),e.exports)</span>;</span></span>var De=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e,r,n)=&gt;{<span class="cstat-no" title="statement not covered" >if(e&amp;&amp;typeof e=="object"||typeof e=="function")<span class="cstat-no" title="statement not covered" >for(let i of Oe(e))<span class="cstat-no" title="statement not covered" >!_e.call(t,i)&amp;&amp;i!==r&amp;&amp;ue(t,i,{get:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >e[i],</span>enumerable:!(n=Pe(e,i))||n.enumerable});<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn t}</span>;</span>var Fe=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e,r)=&gt;(<span class="cstat-no" title="statement not covered" >r=t!=null?Ce(Re(t)):{},De(e||!t||!t.__esModule?ue(r,"default",{value:t,enumerable:!0}):r,t))</span>;</span>var pe=<span class="cstat-no" title="statement not covered" >Me(<span class="fstat-no" title="function not covered" >(d</span>e,fe)=&gt;{<span class="cstat-no" title="statement not covered" >(<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(e){var r=<span class="cstat-no" title="statement not covered" >new t.Builder;<span class="cstat-no" title="statement not covered" ></span>return r.pipeline.add(t.trimmer,t.stopWordFilter,t.stemmer),r.searchPipeline.add(t.stemmer),e.call(r,r),r.build()}</span>;<span class="cstat-no" title="statement not covered" ></span>t.version="2.3.9";<span class="cstat-no" title="statement not covered" >t</span>.utils={},t.utils.warn=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >fu</span>nction(r){<span class="cstat-no" title="statement not covered" >e.console&amp;&amp;console.warn&amp;&amp;console.warn(r)}</span>}</span>(this),t.utils.asString=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return e==null?"":e.toString()}</span>,t.utils.clone=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >if(e==null)<span class="cstat-no" title="statement not covered" >return e;<span class="cstat-no" title="statement not covered" >f</span></span>or(var r=<span class="cstat-no" title="statement not covered" >Object.create(null),</span>n=<span class="cstat-no" title="statement not covered" >Object.keys(e),</span>i=<span class="cstat-no" title="statement not covered" >0;</span>i&lt;n.length;i++){var s=<span class="cstat-no" title="statement not covered" >n[i],</span>o=<span class="cstat-no" title="statement not covered" >e[s];<span class="cstat-no" title="statement not covered" ></span>if(Array.isArray(o)){<span class="cstat-no" title="statement not covered" >r[s]=o.slice();<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>i</span>f(typeof o=="string"||typeof o=="number"||typeof o=="boolean"){<span class="cstat-no" title="statement not covered" >r[s]=o;<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>t</span>hrow new TypeError("clone is not deep and does not support nested objects")}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn r}</span>,t.FieldRef=<span class="fstat-no" title="function not covered" >fu</span>nction(e,r,n){<span class="cstat-no" title="statement not covered" >this.docRef=e,this.fieldName=r,this._stringValue=n}</span>,t.FieldRef.joiner="/",t.FieldRef.fromString=<span class="fstat-no" title="function not covered" >fu</span>nction(e){var r=<span class="cstat-no" title="statement not covered" >e.indexOf(t.FieldRef.joiner);<span class="cstat-no" title="statement not covered" ></span>if(r===-1)<span class="cstat-no" title="statement not covered" >throw"malformed field ref string";v</span></span>ar n=<span class="cstat-no" title="statement not covered" >e.slice(0,r),</span>i=<span class="cstat-no" title="statement not covered" >e.slice(r+1);<span class="cstat-no" title="statement not covered" ></span>return new t.FieldRef(i,n,e)}</span>,t.FieldRef.prototype.toString=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this._stringValue==null&amp;&amp;(this._stringValue=this.fieldName+t.FieldRef.joiner+this.docRef),this._stringValue}</span>;<span class="cstat-no" title="statement not covered" >t</span>.Set=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >if(this.elements=Object.create(null),e){<span class="cstat-no" title="statement not covered" >this.length=e.length;<span class="cstat-no" title="statement not covered" >f</span>or(var r=<span class="cstat-no" title="statement not covered" >0;</span>r&lt;this.length;r++)<span class="cstat-no" title="statement not covered" >this.elements[e[r]]=!0}</span></span>else <span class="cstat-no" title="statement not covered" >this.length=0}</span></span>,t.Set.complete={intersect:<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return e}</span>,union:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this}</span>,contains:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return!0}</span>},t.Set.empty={intersect:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this}</span>,union:<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return e}</span>,contains:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return!1}</span>},t.Set.prototype.contains=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return!!this.elements[e]}</span>,t.Set.prototype.intersect=<span class="fstat-no" title="function not covered" >fu</span>nction(e){var r,n,i,s=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>if(e===t.Set.complete)<span class="cstat-no" title="statement not covered" >return this;<span class="cstat-no" title="statement not covered" >i</span></span>f(e===t.Set.empty)<span class="cstat-no" title="statement not covered" >return e;<span class="cstat-no" title="statement not covered" >t</span></span>his.length&lt;e.length?(r=this,n=e):(r=e,n=this),i=Object.keys(r.elements);<span class="cstat-no" title="statement not covered" >f</span>or(var o=<span class="cstat-no" title="statement not covered" >0;</span>o&lt;i.length;o++){var a=<span class="cstat-no" title="statement not covered" >i[o];<span class="cstat-no" title="statement not covered" ></span>a in n.elements&amp;&amp;s.push(a)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn new t.Set(s)}</span>,t.Set.prototype.union=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return e===t.Set.complete?t.Set.complete:e===t.Set.empty?this:new t.Set(Object.keys(this.elements).concat(Object.keys(e.elements)))}</span>,t.idf=<span class="fstat-no" title="function not covered" >fu</span>nction(e,r){var n=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(var i in e)<span class="cstat-no" title="statement not covered" >i!="_index"&amp;&amp;(n+=Object.keys(e[i]).length);v</span></span>ar s=<span class="cstat-no" title="statement not covered" >(r-n+.5)/(n+.5);<span class="cstat-no" title="statement not covered" ></span>return Math.log(1+Math.abs(s))}</span>,t.Token=<span class="fstat-no" title="function not covered" >fu</span>nction(e,r){<span class="cstat-no" title="statement not covered" >this.str=e||"",this.metadata=r||{}}</span>,t.Token.prototype.toString=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.str}</span>,t.Token.prototype.update=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return this.str=e(this.str,this.metadata),this}</span>,t.Token.prototype.clone=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return e=e||<span class="fstat-no" title="function not covered" >fu</span>nction(r){<span class="cstat-no" title="statement not covered" >return r}</span>,new t.Token(e(this.str,this.metadata),this.metadata)}</span>;<span class="cstat-no" title="statement not covered" >t</span>.tokenizer=<span class="fstat-no" title="function not covered" >fu</span>nction(e,r){<span class="cstat-no" title="statement not covered" >if(e==null||e==null)<span class="cstat-no" title="statement not covered" >return[];<span class="cstat-no" title="statement not covered" >i</span></span>f(Array.isArray(e))<span class="cstat-no" title="statement not covered" >return e.map(<span class="fstat-no" title="function not covered" >fu</span>nction(p){<span class="cstat-no" title="statement not covered" >return new t.Token(t.utils.asString(p).toLowerCase(),t.utils.clone(r))}</span>);<span class="cstat-no" title="statement not covered" >f</span></span>or(var n=<span class="cstat-no" title="statement not covered" >e.toString().toLowerCase(),</span>i=<span class="cstat-no" title="statement not covered" >n.length,</span>s=<span class="cstat-no" title="statement not covered" >[],</span>o=<span class="cstat-no" title="statement not covered" >0,</span>a=<span class="cstat-no" title="statement not covered" >0;</span>o&lt;=i;o++){var u=<span class="cstat-no" title="statement not covered" >n.charAt(o),</span>l=<span class="cstat-no" title="statement not covered" >o-a;<span class="cstat-no" title="statement not covered" ></span>if(u.match(t.tokenizer.separator)||o==i){<span class="cstat-no" title="statement not covered" >if(l&gt;0){var h=<span class="cstat-no" title="statement not covered" >t.utils.clone(r)||{};<span class="cstat-no" title="statement not covered" ></span>h.position=[a,l],h.index=s.length,s.push(new t.Token(n.slice(a,o),h))}<span class="cstat-no" title="statement not covered" ></span>a</span>=o+1}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn s}</span>,t.tokenizer.separator=/[\s\-]+/;<span class="cstat-no" title="statement not covered" >t</span>.Pipeline=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >this._stack=[]}</span>,t.Pipeline.registeredFunctions=Object.create(null),t.Pipeline.registerFunction=<span class="fstat-no" title="function not covered" >fu</span>nction(e,r){<span class="cstat-no" title="statement not covered" >r in this.registeredFunctions&amp;&amp;t.utils.warn("Overwriting existing registered function: "+r),e.label=r,t.Pipeline.registeredFunctions[e.label]=e}</span>,t.Pipeline.warnIfFunctionNotRegistered=<span class="fstat-no" title="function not covered" >fu</span>nction(e){var r=<span class="cstat-no" title="statement not covered" >e.label&amp;&amp;e.label in this.registeredFunctions;<span class="cstat-no" title="statement not covered" ></span>r||t.utils.warn(`Function is not registered with pipeline. This may cause problems when serialising the index.</span></span></span></span></span>
`,e)},t.Pipeline.load=<span class="fstat-no" title="function not covered" >fu</span>nction(e){var r=<span class="cstat-no" title="statement not covered" >new t.Pipeline;<span class="cstat-no" title="statement not covered" ></span>return e.forEach(<span class="fstat-no" title="function not covered" >fu</span>nction(n){var i=<span class="cstat-no" title="statement not covered" >t.Pipeline.registeredFunctions[n];<span class="cstat-no" title="statement not covered" ></span>if(i)<span class="cstat-no" title="statement not covered" >r.add(i);e</span>lse <span class="cstat-no" title="statement not covered" >throw new Error("Cannot load unregistered function: "+n)}</span></span>),r}</span>,t.Pipeline.prototype.add=<span class="fstat-no" title="function not covered" >fu</span>nction(){var e=<span class="cstat-no" title="statement not covered" >Array.prototype.slice.call(arguments);<span class="cstat-no" title="statement not covered" ></span>e.forEach(<span class="fstat-no" title="function not covered" >fu</span>nction(r){<span class="cstat-no" title="statement not covered" >t.Pipeline.warnIfFunctionNotRegistered(r),this._stack.push(r)}</span>,this)}</span>,t.Pipeline.prototype.after=<span class="fstat-no" title="function not covered" >fu</span>nction(e,r){<span class="cstat-no" title="statement not covered" >t.Pipeline.warnIfFunctionNotRegistered(r);v</span>ar n=<span class="cstat-no" title="statement not covered" >this._stack.indexOf(e);<span class="cstat-no" title="statement not covered" ></span>if(n==-1)<span class="cstat-no" title="statement not covered" >throw new Error("Cannot find existingFn");<span class="cstat-no" title="statement not covered" >n</span></span>=n+1,this._stack.splice(n,0,r)}</span>,t.Pipeline.prototype.before=<span class="fstat-no" title="function not covered" >fu</span>nction(e,r){<span class="cstat-no" title="statement not covered" >t.Pipeline.warnIfFunctionNotRegistered(r);v</span>ar n=<span class="cstat-no" title="statement not covered" >this._stack.indexOf(e);<span class="cstat-no" title="statement not covered" ></span>if(n==-1)<span class="cstat-no" title="statement not covered" >throw new Error("Cannot find existingFn");<span class="cstat-no" title="statement not covered" >t</span></span>his._stack.splice(n,0,r)}</span>,t.Pipeline.prototype.remove=<span class="fstat-no" title="function not covered" >fu</span>nction(e){var r=<span class="cstat-no" title="statement not covered" >this._stack.indexOf(e);<span class="cstat-no" title="statement not covered" ></span>r!=-1&amp;&amp;this._stack.splice(r,1)}</span>,t.Pipeline.prototype.run=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >for(var r=<span class="cstat-no" title="statement not covered" >this._stack.length,</span>n=<span class="cstat-no" title="statement not covered" >0;</span>n&lt;r;n++){<span class="cstat-no" title="statement not covered" >for(var i=<span class="cstat-no" title="statement not covered" >this._stack[n],</span>s=<span class="cstat-no" title="statement not covered" >[],</span>o=<span class="cstat-no" title="statement not covered" >0;</span>o&lt;e.length;o++){var a=<span class="cstat-no" title="statement not covered" >i(e[o],o,e);<span class="cstat-no" title="statement not covered" ></span>if(!(a==null||a===""))<span class="cstat-no" title="statement not covered" >if(Array.isArray(a))<span class="cstat-no" title="statement not covered" >for(var u=<span class="cstat-no" title="statement not covered" >0;</span>u&lt;a.length;u++)<span class="cstat-no" title="statement not covered" >s.push(a[u]);e</span></span>lse <span class="cstat-no" title="statement not covered" >s.push(a)}<span class="cstat-no" title="statement not covered" ></span></span></span>e</span>=s}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn e}</span>,t.Pipeline.prototype.runString=<span class="fstat-no" title="function not covered" >fu</span>nction(e,r){var n=<span class="cstat-no" title="statement not covered" >new t.Token(e,r);<span class="cstat-no" title="statement not covered" ></span>return this.run([n]).map(<span class="fstat-no" title="function not covered" >fu</span>nction(i){<span class="cstat-no" title="statement not covered" >return i.toString()}</span>)}</span>,t.Pipeline.prototype.reset=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >this._stack=[]}</span>,t.Pipeline.prototype.toJSON=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this._stack.map(<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return t.Pipeline.warnIfFunctionNotRegistered(e),e.label}</span>)}</span>;<span class="cstat-no" title="statement not covered" >t.Vector=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >this._magnitude=0,this.elements=e||[]}</span>,t.Vector.prototype.positionForIndex=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >if(this.elements.length==0)<span class="cstat-no" title="statement not covered" >return 0;<span class="cstat-no" title="statement not covered" >f</span></span>or(var r=<span class="cstat-no" title="statement not covered" >0,</span>n=<span class="cstat-no" title="statement not covered" >this.elements.length/2,</span>i=<span class="cstat-no" title="statement not covered" >n-r,</span>s=<span class="cstat-no" title="statement not covered" >Math.floor(i/2),</span>o=<span class="cstat-no" title="statement not covered" >this.elements[s*2];</span>i&gt;1&amp;&amp;(o&lt;e&amp;&amp;(r=s),o&gt;e&amp;&amp;(n=s),o!=e);)<span class="cstat-no" title="statement not covered" >i=n-r,s=r+Math.floor(i/2),o=this.elements[s*2];<span class="cstat-no" title="statement not covered" >i</span></span>f(o==e||o&gt;e)<span class="cstat-no" title="statement not covered" >return s*2;<span class="cstat-no" title="statement not covered" >i</span></span>f(o&lt;e)<span class="cstat-no" title="statement not covered" >return(s+1)*2}</span></span>,t.Vector.prototype.insert=<span class="fstat-no" title="function not covered" >fu</span>nction(e,r){<span class="cstat-no" title="statement not covered" >this.upsert(e,r,<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >throw"duplicate index"}</span>)}</span>,t.Vector.prototype.upsert=<span class="fstat-no" title="function not covered" >fu</span>nction(e,r,n){<span class="cstat-no" title="statement not covered" >this._magnitude=0;v</span>ar i=<span class="cstat-no" title="statement not covered" >this.positionForIndex(e);<span class="cstat-no" title="statement not covered" ></span>this.elements[i]==e?this.elements[i+1]=n(this.elements[i+1],r):this.elements.splice(i,0,e,r)}</span>,t.Vector.prototype.magnitude=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >if(this._magnitude)<span class="cstat-no" title="statement not covered" >return this._magnitude;<span class="cstat-no" title="statement not covered" >f</span></span>or(var e=<span class="cstat-no" title="statement not covered" >0,</span>r=<span class="cstat-no" title="statement not covered" >this.elements.length,</span>n=<span class="cstat-no" title="statement not covered" >1;</span>n&lt;r;n+=2){var i=<span class="cstat-no" title="statement not covered" >this.elements[n];<span class="cstat-no" title="statement not covered" ></span>e+=i*i}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn this._magnitude=Math.sqrt(e)}</span>,t.Vector.prototype.dot=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >for(var r=<span class="cstat-no" title="statement not covered" >0,</span>n=<span class="cstat-no" title="statement not covered" >this.elements,</span>i=<span class="cstat-no" title="statement not covered" >e.elements,</span>s=<span class="cstat-no" title="statement not covered" >n.length,</span>o=<span class="cstat-no" title="statement not covered" >i.length,</span>a=<span class="cstat-no" title="statement not covered" >0,</span>u=<span class="cstat-no" title="statement not covered" >0,</span>l=<span class="cstat-no" title="statement not covered" >0,</span>h=<span class="cstat-no" title="statement not covered" >0;</span>l&lt;s&amp;&amp;h&lt;o;)<span class="cstat-no" title="statement not covered" >a=n[l],u=i[h],a&lt;u?l+=2:a&gt;u?h+=2:a==u&amp;&amp;(r+=n[l+1]*i[h+1],l+=2,h+=2);<span class="cstat-no" title="statement not covered" >r</span></span>eturn r}</span>,t.Vector.prototype.similarity=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return this.dot(e)/this.magnitude()||0}</span>,t.Vector.prototype.toArray=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >for(var e=<span class="cstat-no" title="statement not covered" >new Array(this.elements.length/2),</span>r=<span class="cstat-no" title="statement not covered" >1,</span>n=<span class="cstat-no" title="statement not covered" >0;</span>r&lt;this.elements.length;r+=2,n++)<span class="cstat-no" title="statement not covered" >e[n]=this.elements[r];<span class="cstat-no" title="statement not covered" >r</span></span>eturn e}</span>,t.Vector.prototype.toJSON=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.elements}</span>;<span class="cstat-no" title="statement not covered" >t</span>.stemmer=<span class="fstat-no" title="function not covered" >fu</span>nction(){var e=<span class="cstat-no" title="statement not covered" >{ational:"ate",tional:"tion",enci:"ence",anci:"ance",izer:"ize",bli:"ble",alli:"al",entli:"ent",eli:"e",ousli:"ous",ization:"ize",ation:"ate",ator:"ate",alism:"al",iveness:"ive",fulness:"ful",ousness:"ous",aliti:"al",iviti:"ive",biliti:"ble",logi:"log"},</span>r=<span class="cstat-no" title="statement not covered" >{icate:"ic",ative:"",alize:"al",iciti:"ic",ical:"ic",ful:"",ness:""},</span>n=<span class="cstat-no" title="statement not covered" >"[^aeiou]",</span>i=<span class="cstat-no" title="statement not covered" >"[aeiouy]",</span>s=<span class="cstat-no" title="statement not covered" >n+"[^aeiouy]*",</span>o=<span class="cstat-no" title="statement not covered" >i+"[aeiou]*",</span>a=<span class="cstat-no" title="statement not covered" >"^("+s+")?"+o+s,</span>u=<span class="cstat-no" title="statement not covered" >"^("+s+")?"+o+s+"("+o+")?$",</span>l=<span class="cstat-no" title="statement not covered" >"^("+s+")?"+o+s+o+s,</span>h=<span class="cstat-no" title="statement not covered" >"^("+s+")?"+i,</span>p=<span class="cstat-no" title="statement not covered" >new RegExp(a),</span>v=<span class="cstat-no" title="statement not covered" >new RegExp(l),</span>b=<span class="cstat-no" title="statement not covered" >new RegExp(u),</span>y=<span class="cstat-no" title="statement not covered" >new RegExp(h),</span>E=<span class="cstat-no" title="statement not covered" >/^(.+?)(ss|i)es$/,</span>f=<span class="cstat-no" title="statement not covered" >/^(.+?)([^s])s$/,</span>m=<span class="cstat-no" title="statement not covered" >/^(.+?)eed$/,</span>T=<span class="cstat-no" title="statement not covered" >/^(.+?)(ed|ing)$/,</span>w=<span class="cstat-no" title="statement not covered" >/.$/,</span>I=<span class="cstat-no" title="statement not covered" >/(at|bl|iz)$/,</span>M=<span class="cstat-no" title="statement not covered" >new RegExp("([^aeiouylsz])\\1$"),</span>B=<span class="cstat-no" title="statement not covered" >new RegExp("^"+s+i+"[^aeiouwxy]$"),</span>V=<span class="cstat-no" title="statement not covered" >/^(.+?[^aeiou])y$/,</span>q=<span class="cstat-no" title="statement not covered" >/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/,</span>$=<span class="cstat-no" title="statement not covered" >/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/,</span>H=<span class="cstat-no" title="statement not covered" >/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/,</span>W=<span class="cstat-no" title="statement not covered" >/^(.+?)(s|t)(ion)$/,</span>P=<span class="cstat-no" title="statement not covered" >/^(.+?)e$/,</span>U=<span class="cstat-no" title="statement not covered" >/ll$/,</span>G=<span class="cstat-no" title="statement not covered" >new RegExp("^"+s+i+"[^aeiouwxy]$"),</span>z=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(c){var g,O,S,d,x,R,F;<span class="cstat-no" title="statement not covered" >if(c.length&lt;3)<span class="cstat-no" title="statement not covered" >return c;<span class="cstat-no" title="statement not covered" >i</span></span>f(S=c.substr(0,1),S=="y"&amp;&amp;(c=S.toUpperCase()+c.substr(1)),d=E,x=f,d.test(c)?c=c.replace(d,"$1$2"):x.test(c)&amp;&amp;(c=c.replace(x,"$1$2")),d=m,x=T,d.test(c)){var L=<span class="cstat-no" title="statement not covered" >d.exec(c);<span class="cstat-no" title="statement not covered" ></span>d=p,d.test(L[1])&amp;&amp;(d=w,c=c.replace(d,""))}</span>else <span class="cstat-no" title="statement not covered" >if(x.test(c)){var L=<span class="cstat-no" title="statement not covered" >x.exec(c);<span class="cstat-no" title="statement not covered" ></span>g=L[1],x=y,x.test(g)&amp;&amp;(c=g,x=I,R=M,F=B,x.test(c)?c=c+"e":R.test(c)?(d=w,c=c.replace(d,"")):F.test(c)&amp;&amp;(c=c+"e"))}<span class="cstat-no" title="statement not covered" ></span>i</span></span>f(d=V,d.test(c)){var L=<span class="cstat-no" title="statement not covered" >d.exec(c);<span class="cstat-no" title="statement not covered" ></span>g=L[1],c=g+"i"}<span class="cstat-no" title="statement not covered" ></span>i</span>f(d=q,d.test(c)){var L=<span class="cstat-no" title="statement not covered" >d.exec(c);<span class="cstat-no" title="statement not covered" ></span>g=L[1],O=L[2],d=p,d.test(g)&amp;&amp;(c=g+e[O])}<span class="cstat-no" title="statement not covered" ></span>i</span>f(d=$,d.test(c)){var L=<span class="cstat-no" title="statement not covered" >d.exec(c);<span class="cstat-no" title="statement not covered" ></span>g=L[1],O=L[2],d=p,d.test(g)&amp;&amp;(c=g+r[O])}<span class="cstat-no" title="statement not covered" ></span>i</span>f(d=H,x=W,d.test(c)){var L=<span class="cstat-no" title="statement not covered" >d.exec(c);<span class="cstat-no" title="statement not covered" ></span>g=L[1],d=v,d.test(g)&amp;&amp;(c=g)}</span>else <span class="cstat-no" title="statement not covered" >if(x.test(c)){var L=<span class="cstat-no" title="statement not covered" >x.exec(c);<span class="cstat-no" title="statement not covered" ></span>g=L[1]+L[2],x=v,x.test(g)&amp;&amp;(c=g)}<span class="cstat-no" title="statement not covered" ></span>i</span></span>f(d=P,d.test(c)){var L=<span class="cstat-no" title="statement not covered" >d.exec(c);<span class="cstat-no" title="statement not covered" ></span>g=L[1],d=v,x=b,R=G,(d.test(g)||x.test(g)&amp;&amp;!R.test(g))&amp;&amp;(c=g)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn d=U,x=v,d.test(c)&amp;&amp;x.test(c)&amp;&amp;(d=w,c=c.replace(d,"")),S=="y"&amp;&amp;(c=S.toLowerCase()+c.substr(1)),c}</span>;<span class="cstat-no" title="statement not covered" ></span>return <span class="fstat-no" title="function not covered" >fu</span>nction(D){<span class="cstat-no" title="statement not covered" >return D.update(z)}</span>}</span>(),t.Pipeline.registerFunction(t.stemmer,"stemmer");<span class="cstat-no" title="statement not covered" >t</span>.generateStopWordFilter=<span class="fstat-no" title="function not covered" >fu</span>nction(e){var r=<span class="cstat-no" title="statement not covered" >e.reduce(<span class="fstat-no" title="function not covered" >fu</span>nction(n,i){<span class="cstat-no" title="statement not covered" >return n[i]=i,n}</span>,{});<span class="cstat-no" title="statement not covered" ></span>return <span class="fstat-no" title="function not covered" >fu</span>nction(n){<span class="cstat-no" title="statement not covered" >if(n&amp;&amp;r[n.toString()]!==n.toString())<span class="cstat-no" title="statement not covered" >return n}</span></span>}</span>,t.stopWordFilter=t.generateStopWordFilter(["a","able","about","across","after","all","almost","also","am","among","an","and","any","are","as","at","be","because","been","but","by","can","cannot","could","dear","did","do","does","either","else","ever","every","for","from","get","got","had","has","have","he","her","hers","him","his","how","however","i","if","in","into","is","it","its","just","least","let","like","likely","may","me","might","most","must","my","neither","no","nor","not","of","off","often","on","only","or","other","our","own","rather","said","say","says","she","should","since","so","some","than","that","the","their","them","then","there","these","they","this","tis","to","too","twas","us","wants","was","we","were","what","when","where","which","while","who","whom","why","will","with","would","yet","you","your"]),t.Pipeline.registerFunction(t.stopWordFilter,"stopWordFilter");<span class="cstat-no" title="statement not covered" >t</span>.trimmer=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return e.update(<span class="fstat-no" title="function not covered" >fu</span>nction(r){<span class="cstat-no" title="statement not covered" >return r.replace(/^\W+/,"").replace(/\W+$/,"")}</span>)}</span>,t.Pipeline.registerFunction(t.trimmer,"trimmer");<span class="cstat-no" title="statement not covered" >t</span>.TokenSet=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >this.final=!1,this.edges={},this.id=t.TokenSet._nextId,t.TokenSet._nextId+=1}</span>,t.TokenSet._nextId=1,t.TokenSet.fromArray=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >for(var r=<span class="cstat-no" title="statement not covered" >new t.TokenSet.Builder,</span>n=<span class="cstat-no" title="statement not covered" >0,</span>i=<span class="cstat-no" title="statement not covered" >e.length;</span>n&lt;i;n++)<span class="cstat-no" title="statement not covered" >r.insert(e[n]);<span class="cstat-no" title="statement not covered" >r</span></span>eturn r.finish(),r.root}</span>,t.TokenSet.fromClause=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return"editDistance"in e?t.TokenSet.fromFuzzyString(e.term,e.editDistance):t.TokenSet.fromString(e.term)}</span>,t.TokenSet.fromFuzzyString=<span class="fstat-no" title="function not covered" >fu</span>nction(e,r){<span class="cstat-no" title="statement not covered" >for(var n=<span class="cstat-no" title="statement not covered" >new t.TokenSet,</span>i=<span class="cstat-no" title="statement not covered" >[{node:n,editsRemaining:r,str:e}];</span>i.length;){var s=<span class="cstat-no" title="statement not covered" >i.pop();<span class="cstat-no" title="statement not covered" ></span>if(s.str.length&gt;0){var o=<span class="cstat-no" title="statement not covered" >s.str.charAt(0),</span>a;<span class="cstat-no" title="statement not covered" >o in s.node.edges?a=s.node.edges[o]:(a=new t.TokenSet,s.node.edges[o]=a),s.str.length==1&amp;&amp;(a.final=!0),i.push({node:a,editsRemaining:s.editsRemaining,str:s.str.slice(1)})}<span class="cstat-no" title="statement not covered" ></span>i</span>f(s.editsRemaining!=0){<span class="cstat-no" title="statement not covered" >if("*"in s.node.edges)var u=<span class="cstat-no" title="statement not covered" >s.node.edges["*"];</span>else{var u=<span class="cstat-no" title="statement not covered" >new t.TokenSet;<span class="cstat-no" title="statement not covered" ></span>s.node.edges["*"]=u}<span class="cstat-no" title="statement not covered" ></span>i</span>f(s.str.length==0&amp;&amp;(u.final=!0),i.push({node:u,editsRemaining:s.editsRemaining-1,str:s.str}),s.str.length&gt;1&amp;&amp;i.push({node:s.node,editsRemaining:s.editsRemaining-1,str:s.str.slice(1)}),s.str.length==1&amp;&amp;(s.node.final=!0),s.str.length&gt;=1){<span class="cstat-no" title="statement not covered" >if("*"in s.node.edges)var l=<span class="cstat-no" title="statement not covered" >s.node.edges["*"];</span>else{var l=<span class="cstat-no" title="statement not covered" >new t.TokenSet;<span class="cstat-no" title="statement not covered" ></span>s.node.edges["*"]=l}<span class="cstat-no" title="statement not covered" ></span>s</span>.str.length==1&amp;&amp;(l.final=!0),i.push({node:l,editsRemaining:s.editsRemaining-1,str:s.str.slice(1)})}<span class="cstat-no" title="statement not covered" ></span>i</span>f(s.str.length&gt;1){var h=<span class="cstat-no" title="statement not covered" >s.str.charAt(0),</span>p=<span class="cstat-no" title="statement not covered" >s.str.charAt(1),</span>v;<span class="cstat-no" title="statement not covered" >p in s.node.edges?v=s.node.edges[p]:(v=new t.TokenSet,s.node.edges[p]=v),s.str.length==1&amp;&amp;(v.final=!0),i.push({node:v,editsRemaining:s.editsRemaining-1,str:h+s.str.slice(2)})}</span>}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn n}</span>,t.TokenSet.fromString=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >for(var r=<span class="cstat-no" title="statement not covered" >new t.TokenSet,</span>n=<span class="cstat-no" title="statement not covered" >r,</span>i=<span class="cstat-no" title="statement not covered" >0,</span>s=<span class="cstat-no" title="statement not covered" >e.length;</span>i&lt;s;i++){var o=<span class="cstat-no" title="statement not covered" >e[i],</span>a=<span class="cstat-no" title="statement not covered" >i==s-1;<span class="cstat-no" title="statement not covered" ></span>if(o=="*")<span class="cstat-no" title="statement not covered" >r.edges[o]=r,r.final=a;e</span>lse{var u=<span class="cstat-no" title="statement not covered" >new t.TokenSet;<span class="cstat-no" title="statement not covered" ></span>u.final=a,r.edges[o]=u,r=u}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn n}</span>,t.TokenSet.prototype.toArray=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >for(var e=<span class="cstat-no" title="statement not covered" >[],</span>r=<span class="cstat-no" title="statement not covered" >[{prefix:"",node:this}];</span>r.length;){var n=<span class="cstat-no" title="statement not covered" >r.pop(),</span>i=<span class="cstat-no" title="statement not covered" >Object.keys(n.node.edges),</span>s=<span class="cstat-no" title="statement not covered" >i.length;<span class="cstat-no" title="statement not covered" ></span>n.node.final&amp;&amp;(n.prefix.charAt(0),e.push(n.prefix));<span class="cstat-no" title="statement not covered" >f</span>or(var o=<span class="cstat-no" title="statement not covered" >0;</span>o&lt;s;o++){var a=<span class="cstat-no" title="statement not covered" >i[o];<span class="cstat-no" title="statement not covered" ></span>r.push({prefix:n.prefix.concat(a),node:n.node.edges[a]})}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn e}</span>,t.TokenSet.prototype.toString=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >if(this._str)<span class="cstat-no" title="statement not covered" >return this._str;<span class="cstat-no" title="statement not covered" >f</span></span>or(var e=<span class="cstat-no" title="statement not covered" >this.final?"1":"0",</span>r=<span class="cstat-no" title="statement not covered" >Object.keys(this.edges).sort(),</span>n=<span class="cstat-no" title="statement not covered" >r.length,</span>i=<span class="cstat-no" title="statement not covered" >0;</span>i&lt;n;i++){var s=<span class="cstat-no" title="statement not covered" >r[i],</span>o=<span class="cstat-no" title="statement not covered" >this.edges[s];<span class="cstat-no" title="statement not covered" ></span>e=e+s+o.id}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn e}</span>,t.TokenSet.prototype.intersect=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >for(var r=<span class="cstat-no" title="statement not covered" >new t.TokenSet,</span>n=<span class="cstat-no" title="statement not covered" >void 0,</span>i=<span class="cstat-no" title="statement not covered" >[{qNode:e,output:r,node:this}];</span>i.length;){<span class="cstat-no" title="statement not covered" >n=i.pop();<span class="cstat-no" title="statement not covered" >f</span>or(var s=<span class="cstat-no" title="statement not covered" >Object.keys(n.qNode.edges),</span>o=<span class="cstat-no" title="statement not covered" >s.length,</span>a=<span class="cstat-no" title="statement not covered" >Object.keys(n.node.edges),</span>u=<span class="cstat-no" title="statement not covered" >a.length,</span>l=<span class="cstat-no" title="statement not covered" >0;</span>l&lt;o;l++)<span class="cstat-no" title="statement not covered" >for(var h=<span class="cstat-no" title="statement not covered" >s[l],</span>p=<span class="cstat-no" title="statement not covered" >0;</span>p&lt;u;p++){var v=<span class="cstat-no" title="statement not covered" >a[p];<span class="cstat-no" title="statement not covered" ></span>if(v==h||h=="*"){var b=<span class="cstat-no" title="statement not covered" >n.node.edges[v],</span>y=<span class="cstat-no" title="statement not covered" >n.qNode.edges[h],</span>E=<span class="cstat-no" title="statement not covered" >b.final&amp;&amp;y.final,</span>f=<span class="cstat-no" title="statement not covered" >void 0;<span class="cstat-no" title="statement not covered" ></span>v in n.output.edges?(f=n.output.edges[v],f.final=f.final||E):(f=new t.TokenSet,f.final=E,n.output.edges[v]=f),i.push({qNode:y,output:f,node:b})}</span>}</span>}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn r}</span>,t.TokenSet.Builder=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >this.previousWord="",this.root=new t.TokenSet,this.uncheckedNodes=[],this.minimizedNodes={}}</span>,t.TokenSet.Builder.prototype.insert=<span class="fstat-no" title="function not covered" >fu</span>nction(e){var r,n=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>if(e&lt;this.previousWord)<span class="cstat-no" title="statement not covered" >throw new Error("Out of order word insertion");<span class="cstat-no" title="statement not covered" >f</span></span>or(var i=<span class="cstat-no" title="statement not covered" >0;</span>i&lt;e.length&amp;&amp;i&lt;this.previousWord.length&amp;&amp;e[i]==this.previousWord[i];i++)<span class="cstat-no" title="statement not covered" >n++;<span class="cstat-no" title="statement not covered" >t</span></span>his.minimize(n),this.uncheckedNodes.length==0?r=this.root:r=this.uncheckedNodes[this.uncheckedNodes.length-1].child;<span class="cstat-no" title="statement not covered" >f</span>or(var i=<span class="cstat-no" title="statement not covered" >n;</span>i&lt;e.length;i++){var s=<span class="cstat-no" title="statement not covered" >new t.TokenSet,</span>o=<span class="cstat-no" title="statement not covered" >e[i];<span class="cstat-no" title="statement not covered" ></span>r.edges[o]=s,this.uncheckedNodes.push({parent:r,char:o,child:s}),r=s}<span class="cstat-no" title="statement not covered" ></span>r</span>.final=!0,this.previousWord=e}</span>,t.TokenSet.Builder.prototype.finish=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >this.minimize(0)}</span>,t.TokenSet.Builder.prototype.minimize=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >for(var r=<span class="cstat-no" title="statement not covered" >this.uncheckedNodes.length-1;</span>r&gt;=e;r--){var n=<span class="cstat-no" title="statement not covered" >this.uncheckedNodes[r],</span>i=<span class="cstat-no" title="statement not covered" >n.child.toString();<span class="cstat-no" title="statement not covered" ></span>i in this.minimizedNodes?n.parent.edges[n.char]=this.minimizedNodes[i]:(n.child._str=i,this.minimizedNodes[i]=n.child),this.uncheckedNodes.pop()}</span>}</span>;<span class="cstat-no" title="statement not covered" >t</span>.Index=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >this.invertedIndex=e.invertedIndex,this.fieldVectors=e.fieldVectors,this.tokenSet=e.tokenSet,this.fields=e.fields,this.pipeline=e.pipeline}</span>,t.Index.prototype.search=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return this.query(<span class="fstat-no" title="function not covered" >fu</span>nction(r){var n=<span class="cstat-no" title="statement not covered" >new t.QueryParser(e,r);<span class="cstat-no" title="statement not covered" ></span>n.parse()}</span>)}</span>,t.Index.prototype.query=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >for(var r=<span class="cstat-no" title="statement not covered" >new t.Query(this.fields),</span>n=<span class="cstat-no" title="statement not covered" >Object.create(null),</span>i=<span class="cstat-no" title="statement not covered" >Object.create(null),</span>s=<span class="cstat-no" title="statement not covered" >Object.create(null),</span>o=<span class="cstat-no" title="statement not covered" >Object.create(null),</span>a=<span class="cstat-no" title="statement not covered" >Object.create(null),</span>u=<span class="cstat-no" title="statement not covered" >0;</span>u&lt;this.fields.length;u++)<span class="cstat-no" title="statement not covered" >i[this.fields[u]]=new t.Vector;<span class="cstat-no" title="statement not covered" >e</span></span>.call(r,r);<span class="cstat-no" title="statement not covered" >f</span>or(var u=<span class="cstat-no" title="statement not covered" >0;</span>u&lt;r.clauses.length;u++){var l=<span class="cstat-no" title="statement not covered" >r.clauses[u],</span>h=<span class="cstat-no" title="statement not covered" >null,</span>p=<span class="cstat-no" title="statement not covered" >t.Set.empty;<span class="cstat-no" title="statement not covered" ></span>l.usePipeline?h=this.pipeline.runString(l.term,{fields:l.fields}):h=[l.term];<span class="cstat-no" title="statement not covered" >f</span>or(var v=<span class="cstat-no" title="statement not covered" >0;</span>v&lt;h.length;v++){var b=<span class="cstat-no" title="statement not covered" >h[v];<span class="cstat-no" title="statement not covered" ></span>l.term=b;v</span>ar y=<span class="cstat-no" title="statement not covered" >t.TokenSet.fromClause(l),</span>E=<span class="cstat-no" title="statement not covered" >this.tokenSet.intersect(y).toArray();<span class="cstat-no" title="statement not covered" ></span>if(E.length===0&amp;&amp;l.presence===t.Query.presence.REQUIRED){<span class="cstat-no" title="statement not covered" >for(var f=<span class="cstat-no" title="statement not covered" >0;</span>f&lt;l.fields.length;f++){var m=<span class="cstat-no" title="statement not covered" >l.fields[f];<span class="cstat-no" title="statement not covered" ></span>o[m]=t.Set.empty}<span class="cstat-no" title="statement not covered" ></span>b</span>reak}<span class="cstat-no" title="statement not covered" ></span>f</span>or(var T=<span class="cstat-no" title="statement not covered" >0;</span>T&lt;E.length;T++)<span class="cstat-no" title="statement not covered" >for(var w=<span class="cstat-no" title="statement not covered" >E[T],</span>I=<span class="cstat-no" title="statement not covered" >this.invertedIndex[w],</span>M=<span class="cstat-no" title="statement not covered" >I._index,</span>f=<span class="cstat-no" title="statement not covered" >0;</span>f&lt;l.fields.length;f++){var m=<span class="cstat-no" title="statement not covered" >l.fields[f],</span>B=<span class="cstat-no" title="statement not covered" >I[m],</span>V=<span class="cstat-no" title="statement not covered" >Object.keys(B),</span>q=<span class="cstat-no" title="statement not covered" >w+"/"+m,</span>$=<span class="cstat-no" title="statement not covered" >new t.Set(V);<span class="cstat-no" title="statement not covered" ></span>if(l.presence==t.Query.presence.REQUIRED&amp;&amp;(p=p.union($),o[m]===void 0&amp;&amp;(o[m]=t.Set.complete)),l.presence==t.Query.presence.PROHIBITED){<span class="cstat-no" title="statement not covered" >a[m]===void 0&amp;&amp;(a[m]=t.Set.empty),a[m]=a[m].union($);<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>i</span>f(i[m].upsert(M,l.boost,<span class="fstat-no" title="function not covered" >fu</span>nction(Qe,Ie){<span class="cstat-no" title="statement not covered" >return Qe+Ie}</span>),!s[q]){<span class="cstat-no" title="statement not covered" >for(var H=<span class="cstat-no" title="statement not covered" >0;</span>H&lt;V.length;H++){var W=<span class="cstat-no" title="statement not covered" >V[H],</span>P=<span class="cstat-no" title="statement not covered" >new t.FieldRef(W,m),</span>U=<span class="cstat-no" title="statement not covered" >B[W],</span>G;<span class="cstat-no" title="statement not covered" >(G=n[P])===void 0?n[P]=new t.MatchData(w,m,U):G.add(w,m,U)}<span class="cstat-no" title="statement not covered" ></span>s</span>[q]=!0}</span>}</span>}<span class="cstat-no" title="statement not covered" ></span></span>i</span>f(l.presence===t.Query.presence.REQUIRED)<span class="cstat-no" title="statement not covered" >for(var f=<span class="cstat-no" title="statement not covered" >0;</span>f&lt;l.fields.length;f++){var m=<span class="cstat-no" title="statement not covered" >l.fields[f];<span class="cstat-no" title="statement not covered" ></span>o[m]=o[m].intersect(p)}</span>}<span class="cstat-no" title="statement not covered" ></span></span>f</span>or(var z=<span class="cstat-no" title="statement not covered" >t.Set.complete,</span>D=<span class="cstat-no" title="statement not covered" >t.Set.empty,</span>u=<span class="cstat-no" title="statement not covered" >0;</span>u&lt;this.fields.length;u++){var m=<span class="cstat-no" title="statement not covered" >this.fields[u];<span class="cstat-no" title="statement not covered" ></span>o[m]&amp;&amp;(z=z.intersect(o[m])),a[m]&amp;&amp;(D=D.union(a[m]))}</span>v</span>ar c=<span class="cstat-no" title="statement not covered" >Object.keys(n),</span>g=<span class="cstat-no" title="statement not covered" >[],</span>O=<span class="cstat-no" title="statement not covered" >Object.create(null);<span class="cstat-no" title="statement not covered" ></span>if(r.isNegated()){<span class="cstat-no" title="statement not covered" >c=Object.keys(this.fieldVectors);<span class="cstat-no" title="statement not covered" >f</span>or(var u=<span class="cstat-no" title="statement not covered" >0;</span>u&lt;c.length;u++){var P=<span class="cstat-no" title="statement not covered" >c[u],</span>S=<span class="cstat-no" title="statement not covered" >t.FieldRef.fromString(P);<span class="cstat-no" title="statement not covered" ></span>n[P]=new t.MatchData}</span>}<span class="cstat-no" title="statement not covered" ></span>f</span>or(var u=<span class="cstat-no" title="statement not covered" >0;</span>u&lt;c.length;u++){var S=<span class="cstat-no" title="statement not covered" >t.FieldRef.fromString(c[u]),</span>d=<span class="cstat-no" title="statement not covered" >S.docRef;<span class="cstat-no" title="statement not covered" ></span>if(!!z.contains(d)&amp;&amp;!D.contains(d)){var x=<span class="cstat-no" title="statement not covered" >this.fieldVectors[S],</span>R=<span class="cstat-no" title="statement not covered" >i[S.fieldName].similarity(x),</span>F;<span class="cstat-no" title="statement not covered" >if((F=O[d])!==void 0)<span class="cstat-no" title="statement not covered" >F.score+=R,F.matchData.combine(n[S]);e</span>lse{var L=<span class="cstat-no" title="statement not covered" >{ref:d,score:R,matchData:n[S]};<span class="cstat-no" title="statement not covered" ></span>O[d]=L,g.push(L)}</span>}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn g.sort(<span class="fstat-no" title="function not covered" >fu</span>nction(Se,ke){<span class="cstat-no" title="statement not covered" >return ke.score-Se.score}</span>)}</span>,t.Index.prototype.toJSON=<span class="fstat-no" title="function not covered" >fu</span>nction(){var e=<span class="cstat-no" title="statement not covered" >Object.keys(this.invertedIndex).sort().map(<span class="fstat-no" title="function not covered" >fu</span>nction(n){<span class="cstat-no" title="statement not covered" >return[n,this.invertedIndex[n]]}</span>,this),</span>r=<span class="cstat-no" title="statement not covered" >Object.keys(this.fieldVectors).map(<span class="fstat-no" title="function not covered" >fu</span>nction(n){<span class="cstat-no" title="statement not covered" >return[n,this.fieldVectors[n].toJSON()]}</span>,this);<span class="cstat-no" title="statement not covered" ></span>return{version:t.version,fields:this.fields,fieldVectors:r,invertedIndex:e,pipeline:this.pipeline.toJSON()}}</span>,t.Index.load=<span class="fstat-no" title="function not covered" >fu</span>nction(e){var r=<span class="cstat-no" title="statement not covered" >{},</span>n=<span class="cstat-no" title="statement not covered" >{},</span>i=<span class="cstat-no" title="statement not covered" >e.fieldVectors,</span>s=<span class="cstat-no" title="statement not covered" >Object.create(null),</span>o=<span class="cstat-no" title="statement not covered" >e.invertedIndex,</span>a=<span class="cstat-no" title="statement not covered" >new t.TokenSet.Builder,</span>u=<span class="cstat-no" title="statement not covered" >t.Pipeline.load(e.pipeline);<span class="cstat-no" title="statement not covered" ></span>e.version!=t.version&amp;&amp;t.utils.warn("Version mismatch when loading serialised index. Current version of lunr '"+t.version+"' does not match serialized index '"+e.version+"'");<span class="cstat-no" title="statement not covered" >f</span>or(var l=<span class="cstat-no" title="statement not covered" >0;</span>l&lt;i.length;l++){var h=<span class="cstat-no" title="statement not covered" >i[l],</span>p=<span class="cstat-no" title="statement not covered" >h[0],</span>v=<span class="cstat-no" title="statement not covered" >h[1];<span class="cstat-no" title="statement not covered" ></span>n[p]=new t.Vector(v)}<span class="cstat-no" title="statement not covered" ></span>f</span>or(var l=<span class="cstat-no" title="statement not covered" >0;</span>l&lt;o.length;l++){var h=<span class="cstat-no" title="statement not covered" >o[l],</span>b=<span class="cstat-no" title="statement not covered" >h[0],</span>y=<span class="cstat-no" title="statement not covered" >h[1];<span class="cstat-no" title="statement not covered" ></span>a.insert(b),s[b]=y}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn a.finish(),r.fields=e.fields,r.fieldVectors=n,r.invertedIndex=s,r.tokenSet=a.root,r.pipeline=u,new t.Index(r)}</span>;<span class="cstat-no" title="statement not covered" >t</span>.Builder=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >this._ref="id",this._fields=Object.create(null),this._documents=Object.create(null),this.invertedIndex=Object.create(null),this.fieldTermFrequencies={},this.fieldLengths={},this.tokenizer=t.tokenizer,this.pipeline=new t.Pipeline,this.searchPipeline=new t.Pipeline,this.documentCount=0,this._b=.75,this._k1=1.2,this.termIndex=0,this.metadataWhitelist=[]}</span>,t.Builder.prototype.ref=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >this._ref=e}</span>,t.Builder.prototype.field=<span class="fstat-no" title="function not covered" >fu</span>nction(e,r){<span class="cstat-no" title="statement not covered" >if(/\//.test(e))<span class="cstat-no" title="statement not covered" >throw new RangeError("Field '"+e+"' contains illegal character '/'");<span class="cstat-no" title="statement not covered" >t</span></span>his._fields[e]=r||{}}</span>,t.Builder.prototype.b=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >e&lt;0?this._b=0:e&gt;1?this._b=1:this._b=e}</span>,t.Builder.prototype.k1=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >this._k1=e}</span>,t.Builder.prototype.add=<span class="fstat-no" title="function not covered" >fu</span>nction(e,r){var n=<span class="cstat-no" title="statement not covered" >e[this._ref],</span>i=<span class="cstat-no" title="statement not covered" >Object.keys(this._fields);<span class="cstat-no" title="statement not covered" ></span>this._documents[n]=r||{},this.documentCount+=1;<span class="cstat-no" title="statement not covered" >f</span>or(var s=<span class="cstat-no" title="statement not covered" >0;</span>s&lt;i.length;s++){var o=<span class="cstat-no" title="statement not covered" >i[s],</span>a=<span class="cstat-no" title="statement not covered" >this._fields[o].extractor,</span>u=<span class="cstat-no" title="statement not covered" >a?a(e):e[o],</span>l=<span class="cstat-no" title="statement not covered" >this.tokenizer(u,{fields:[o]}),</span>h=<span class="cstat-no" title="statement not covered" >this.pipeline.run(l),</span>p=<span class="cstat-no" title="statement not covered" >new t.FieldRef(n,o),</span>v=<span class="cstat-no" title="statement not covered" >Object.create(null);<span class="cstat-no" title="statement not covered" ></span>this.fieldTermFrequencies[p]=v,this.fieldLengths[p]=0,this.fieldLengths[p]+=h.length;<span class="cstat-no" title="statement not covered" >f</span>or(var b=<span class="cstat-no" title="statement not covered" >0;</span>b&lt;h.length;b++){var y=<span class="cstat-no" title="statement not covered" >h[b];<span class="cstat-no" title="statement not covered" ></span>if(v[y]==null&amp;&amp;(v[y]=0),v[y]+=1,this.invertedIndex[y]==null){var E=<span class="cstat-no" title="statement not covered" >Object.create(null);<span class="cstat-no" title="statement not covered" ></span>E._index=this.termIndex,this.termIndex+=1;<span class="cstat-no" title="statement not covered" >f</span>or(var f=<span class="cstat-no" title="statement not covered" >0;</span>f&lt;i.length;f++)<span class="cstat-no" title="statement not covered" >E[i[f]]=Object.create(null);<span class="cstat-no" title="statement not covered" >t</span></span>his.invertedIndex[y]=E}<span class="cstat-no" title="statement not covered" ></span>t</span>his.invertedIndex[y][o][n]==null&amp;&amp;(this.invertedIndex[y][o][n]=Object.create(null));<span class="cstat-no" title="statement not covered" >f</span>or(var m=<span class="cstat-no" title="statement not covered" >0;</span>m&lt;this.metadataWhitelist.length;m++){var T=<span class="cstat-no" title="statement not covered" >this.metadataWhitelist[m],</span>w=<span class="cstat-no" title="statement not covered" >y.metadata[T];<span class="cstat-no" title="statement not covered" ></span>this.invertedIndex[y][o][n][T]==null&amp;&amp;(this.invertedIndex[y][o][n][T]=[]),this.invertedIndex[y][o][n][T].push(w)}</span>}</span>}</span>}</span>,t.Builder.prototype.calculateAverageFieldLengths=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >for(var e=<span class="cstat-no" title="statement not covered" >Object.keys(this.fieldLengths),</span>r=<span class="cstat-no" title="statement not covered" >e.length,</span>n=<span class="cstat-no" title="statement not covered" >{},</span>i=<span class="cstat-no" title="statement not covered" >{},</span>s=<span class="cstat-no" title="statement not covered" >0;</span>s&lt;r;s++){var o=<span class="cstat-no" title="statement not covered" >t.FieldRef.fromString(e[s]),</span>a=<span class="cstat-no" title="statement not covered" >o.fieldName;<span class="cstat-no" title="statement not covered" ></span>i[a]||(i[a]=0),i[a]+=1,n[a]||(n[a]=0),n[a]+=this.fieldLengths[o]}<span class="cstat-no" title="statement not covered" ></span>f</span>or(var u=<span class="cstat-no" title="statement not covered" >Object.keys(this._fields),</span>s=<span class="cstat-no" title="statement not covered" >0;</span>s&lt;u.length;s++){var l=<span class="cstat-no" title="statement not covered" >u[s];<span class="cstat-no" title="statement not covered" ></span>n[l]=n[l]/i[l]}<span class="cstat-no" title="statement not covered" ></span>t</span>his.averageFieldLength=n}</span>,t.Builder.prototype.createFieldVectors=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >for(var e=<span class="cstat-no" title="statement not covered" >{},</span>r=<span class="cstat-no" title="statement not covered" >Object.keys(this.fieldTermFrequencies),</span>n=<span class="cstat-no" title="statement not covered" >r.length,</span>i=<span class="cstat-no" title="statement not covered" >Object.create(null),</span>s=<span class="cstat-no" title="statement not covered" >0;</span>s&lt;n;s++){<span class="cstat-no" title="statement not covered" >for(var o=<span class="cstat-no" title="statement not covered" >t.FieldRef.fromString(r[s]),</span>a=<span class="cstat-no" title="statement not covered" >o.fieldName,</span>u=<span class="cstat-no" title="statement not covered" >this.fieldLengths[o],</span>l=<span class="cstat-no" title="statement not covered" >new t.Vector,</span>h=<span class="cstat-no" title="statement not covered" >this.fieldTermFrequencies[o],</span>p=<span class="cstat-no" title="statement not covered" >Object.keys(h),</span>v=<span class="cstat-no" title="statement not covered" >p.length,</span>b=<span class="cstat-no" title="statement not covered" >this._fields[a].boost||1,</span>y=<span class="cstat-no" title="statement not covered" >this._documents[o.docRef].boost||1,</span>E=<span class="cstat-no" title="statement not covered" >0;</span>E&lt;v;E++){var f=<span class="cstat-no" title="statement not covered" >p[E],</span>m=<span class="cstat-no" title="statement not covered" >h[f],</span>T=<span class="cstat-no" title="statement not covered" >this.invertedIndex[f]._index,</span>w,I,M;<span class="cstat-no" title="statement not covered" >i[f]===void 0?(w=t.idf(this.invertedIndex[f],this.documentCount),i[f]=w):w=i[f],I=w*((this._k1+1)*m)/(this._k1*(1-this._b+this._b*(u/this.averageFieldLength[a]))+m),I*=b,I*=y,M=Math.round(I*1e3)/1e3,l.insert(T,M)}<span class="cstat-no" title="statement not covered" ></span>e</span>[o]=l}<span class="cstat-no" title="statement not covered" ></span>t</span>his.fieldVectors=e}</span>,t.Builder.prototype.createTokenSet=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >this.tokenSet=t.TokenSet.fromArray(Object.keys(this.invertedIndex).sort())}</span>,t.Builder.prototype.build=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.calculateAverageFieldLengths(),this.createFieldVectors(),this.createTokenSet(),new t.Index({invertedIndex:this.invertedIndex,fieldVectors:this.fieldVectors,tokenSet:this.tokenSet,fields:Object.keys(this._fields),pipeline:this.searchPipeline})}</span>,t.Builder.prototype.use=<span class="fstat-no" title="function not covered" >fu</span>nction(e){var r=<span class="cstat-no" title="statement not covered" >Array.prototype.slice.call(arguments,1);<span class="cstat-no" title="statement not covered" ></span>r.unshift(this),e.apply(this,r)}</span>,t.MatchData=<span class="fstat-no" title="function not covered" >fu</span>nction(e,r,n){<span class="cstat-no" title="statement not covered" >for(var i=<span class="cstat-no" title="statement not covered" >Object.create(null),</span>s=<span class="cstat-no" title="statement not covered" >Object.keys(n||{}),</span>o=<span class="cstat-no" title="statement not covered" >0;</span>o&lt;s.length;o++){var a=<span class="cstat-no" title="statement not covered" >s[o];<span class="cstat-no" title="statement not covered" ></span>i[a]=n[a].slice()}<span class="cstat-no" title="statement not covered" ></span>t</span>his.metadata=Object.create(null),e!==void 0&amp;&amp;(this.metadata[e]=Object.create(null),this.metadata[e][r]=i)}</span>,t.MatchData.prototype.combine=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >for(var r=<span class="cstat-no" title="statement not covered" >Object.keys(e.metadata),</span>n=<span class="cstat-no" title="statement not covered" >0;</span>n&lt;r.length;n++){var i=<span class="cstat-no" title="statement not covered" >r[n],</span>s=<span class="cstat-no" title="statement not covered" >Object.keys(e.metadata[i]);<span class="cstat-no" title="statement not covered" ></span>this.metadata[i]==null&amp;&amp;(this.metadata[i]=Object.create(null));<span class="cstat-no" title="statement not covered" >f</span>or(var o=<span class="cstat-no" title="statement not covered" >0;</span>o&lt;s.length;o++){var a=<span class="cstat-no" title="statement not covered" >s[o],</span>u=<span class="cstat-no" title="statement not covered" >Object.keys(e.metadata[i][a]);<span class="cstat-no" title="statement not covered" ></span>this.metadata[i][a]==null&amp;&amp;(this.metadata[i][a]=Object.create(null));<span class="cstat-no" title="statement not covered" >f</span>or(var l=<span class="cstat-no" title="statement not covered" >0;</span>l&lt;u.length;l++){var h=<span class="cstat-no" title="statement not covered" >u[l];<span class="cstat-no" title="statement not covered" ></span>this.metadata[i][a][h]==null?this.metadata[i][a][h]=e.metadata[i][a][h]:this.metadata[i][a][h]=this.metadata[i][a][h].concat(e.metadata[i][a][h])}</span>}</span>}</span>}</span>,t.MatchData.prototype.add=<span class="fstat-no" title="function not covered" >fu</span>nction(e,r,n){<span class="cstat-no" title="statement not covered" >if(!(e in this.metadata)){<span class="cstat-no" title="statement not covered" >this.metadata[e]=Object.create(null),this.metadata[e][r]=n;<span class="cstat-no" title="statement not covered" >r</span>eturn}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!(r in this.metadata[e])){<span class="cstat-no" title="statement not covered" >this.metadata[e][r]=n;<span class="cstat-no" title="statement not covered" >r</span>eturn}<span class="cstat-no" title="statement not covered" ></span>f</span>or(var i=<span class="cstat-no" title="statement not covered" >Object.keys(n),</span>s=<span class="cstat-no" title="statement not covered" >0;</span>s&lt;i.length;s++){var o=<span class="cstat-no" title="statement not covered" >i[s];<span class="cstat-no" title="statement not covered" ></span>o in this.metadata[e][r]?this.metadata[e][r][o]=this.metadata[e][r][o].concat(n[o]):this.metadata[e][r][o]=n[o]}</span>}</span>,t.Query=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >this.clauses=[],this.allFields=e}</span>,t.Query.wildcard=new String("*"),t.Query.wildcard.NONE=0,t.Query.wildcard.LEADING=1,t.Query.wildcard.TRAILING=2,t.Query.presence={OPTIONAL:1,REQUIRED:2,PROHIBITED:3},t.Query.prototype.clause=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return"fields"in e||(e.fields=this.allFields),"boost"in e||(e.boost=1),"usePipeline"in e||(e.usePipeline=!0),"wildcard"in e||(e.wildcard=t.Query.wildcard.NONE),e.wildcard&amp;t.Query.wildcard.LEADING&amp;&amp;e.term.charAt(0)!=t.Query.wildcard&amp;&amp;(e.term="*"+e.term),e.wildcard&amp;t.Query.wildcard.TRAILING&amp;&amp;e.term.slice(-1)!=t.Query.wildcard&amp;&amp;(e.term=""+e.term+"*"),"presence"in e||(e.presence=t.Query.presence.OPTIONAL),this.clauses.push(e),this}</span>,t.Query.prototype.isNegated=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >for(var e=<span class="cstat-no" title="statement not covered" >0;</span>e&lt;this.clauses.length;e++)<span class="cstat-no" title="statement not covered" >if(this.clauses[e].presence!=t.Query.presence.PROHIBITED)<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn!0}</span>,t.Query.prototype.term=<span class="fstat-no" title="function not covered" >fu</span>nction(e,r){<span class="cstat-no" title="statement not covered" >if(Array.isArray(e))<span class="cstat-no" title="statement not covered" >return e.forEach(<span class="fstat-no" title="function not covered" >fu</span>nction(i){<span class="cstat-no" title="statement not covered" >this.term(i,t.utils.clone(r))}</span>,this),this;v</span></span>ar n=<span class="cstat-no" title="statement not covered" >r||{};<span class="cstat-no" title="statement not covered" ></span>return n.term=e.toString(),this.clause(n),this}</span>,t.QueryParseError=<span class="fstat-no" title="function not covered" >fu</span>nction(e,r,n){<span class="cstat-no" title="statement not covered" >this.name="QueryParseError",this.message=e,this.start=r,this.end=n}</span>,t.QueryParseError.prototype=new Error,t.QueryLexer=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >this.lexemes=[],this.str=e,this.length=e.length,this.pos=0,this.start=0,this.escapeCharPositions=[]}</span>,t.QueryLexer.prototype.run=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >for(var e=<span class="cstat-no" title="statement not covered" >t.QueryLexer.lexText;</span>e;)<span class="cstat-no" title="statement not covered" >e=e(this)}</span></span>,t.QueryLexer.prototype.sliceString=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >for(var e=<span class="cstat-no" title="statement not covered" >[],</span>r=<span class="cstat-no" title="statement not covered" >this.start,</span>n=<span class="cstat-no" title="statement not covered" >this.pos,</span>i=<span class="cstat-no" title="statement not covered" >0;</span>i&lt;this.escapeCharPositions.length;i++)<span class="cstat-no" title="statement not covered" >n=this.escapeCharPositions[i],e.push(this.str.slice(r,n)),r=n+1;<span class="cstat-no" title="statement not covered" >r</span></span>eturn e.push(this.str.slice(r,this.pos)),this.escapeCharPositions.length=0,e.join("")}</span>,t.QueryLexer.prototype.emit=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >this.lexemes.push({type:e,str:this.sliceString(),start:this.start,end:this.pos}),this.start=this.pos}</span>,t.QueryLexer.prototype.escapeCharacter=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >this.escapeCharPositions.push(this.pos-1),this.pos+=1}</span>,t.QueryLexer.prototype.next=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >if(this.pos&gt;=this.length)<span class="cstat-no" title="statement not covered" >return t.QueryLexer.EOS;v</span></span>ar e=<span class="cstat-no" title="statement not covered" >this.str.charAt(this.pos);<span class="cstat-no" title="statement not covered" ></span>return this.pos+=1,e}</span>,t.QueryLexer.prototype.width=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.pos-this.start}</span>,t.QueryLexer.prototype.ignore=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >this.start==this.pos&amp;&amp;(this.pos+=1),this.start=this.pos}</span>,t.QueryLexer.prototype.backup=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >this.pos-=1}</span>,t.QueryLexer.prototype.acceptDigitRun=<span class="fstat-no" title="function not covered" >fu</span>nction(){var e,r;<span class="cstat-no" title="statement not covered" >do <span class="cstat-no" title="statement not covered" >e=this.next(),r=e.charCodeAt(0);w</span>hile(r&gt;47&amp;&amp;r&lt;58);<span class="cstat-no" title="statement not covered" >e</span>!=t.QueryLexer.EOS&amp;&amp;this.backup()}</span>,t.QueryLexer.prototype.more=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.pos&lt;this.length}</span>,t.QueryLexer.EOS="EOS",t.QueryLexer.FIELD="FIELD",t.QueryLexer.TERM="TERM",t.QueryLexer.EDIT_DISTANCE="EDIT_DISTANCE",t.QueryLexer.BOOST="BOOST",t.QueryLexer.PRESENCE="PRESENCE",t.QueryLexer.lexField=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return e.backup(),e.emit(t.QueryLexer.FIELD),e.ignore(),t.QueryLexer.lexText}</span>,t.QueryLexer.lexTerm=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >if(e.width()&gt;1&amp;&amp;(e.backup(),e.emit(t.QueryLexer.TERM)),e.ignore(),e.more())<span class="cstat-no" title="statement not covered" >return t.QueryLexer.lexText}</span></span>,t.QueryLexer.lexEditDistance=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return e.ignore(),e.acceptDigitRun(),e.emit(t.QueryLexer.EDIT_DISTANCE),t.QueryLexer.lexText}</span>,t.QueryLexer.lexBoost=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return e.ignore(),e.acceptDigitRun(),e.emit(t.QueryLexer.BOOST),t.QueryLexer.lexText}</span>,t.QueryLexer.lexEOS=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >e.width()&gt;0&amp;&amp;e.emit(t.QueryLexer.TERM)}</span>,t.QueryLexer.termSeparator=t.tokenizer.separator,t.QueryLexer.lexText=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >for(;;){var r=<span class="cstat-no" title="statement not covered" >e.next();<span class="cstat-no" title="statement not covered" ></span>if(r==t.QueryLexer.EOS)<span class="cstat-no" title="statement not covered" >return t.QueryLexer.lexEOS;<span class="cstat-no" title="statement not covered" >i</span></span>f(r.charCodeAt(0)==92){<span class="cstat-no" title="statement not covered" >e.escapeCharacter();<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>i</span>f(r==":")<span class="cstat-no" title="statement not covered" >return t.QueryLexer.lexField;<span class="cstat-no" title="statement not covered" >i</span></span>f(r=="~")<span class="cstat-no" title="statement not covered" >return e.backup(),e.width()&gt;0&amp;&amp;e.emit(t.QueryLexer.TERM),t.QueryLexer.lexEditDistance;<span class="cstat-no" title="statement not covered" >i</span></span>f(r=="^")<span class="cstat-no" title="statement not covered" >return e.backup(),e.width()&gt;0&amp;&amp;e.emit(t.QueryLexer.TERM),t.QueryLexer.lexBoost;<span class="cstat-no" title="statement not covered" >i</span></span>f(r=="+"&amp;&amp;e.width()===1||r=="-"&amp;&amp;e.width()===1)<span class="cstat-no" title="statement not covered" >return e.emit(t.QueryLexer.PRESENCE),t.QueryLexer.lexText;<span class="cstat-no" title="statement not covered" >i</span></span>f(r.match(t.QueryLexer.termSeparator))<span class="cstat-no" title="statement not covered" >return t.QueryLexer.lexTerm}</span></span>}</span>,t.QueryParser=<span class="fstat-no" title="function not covered" >fu</span>nction(e,r){<span class="cstat-no" title="statement not covered" >this.lexer=new t.QueryLexer(e),this.query=r,this.currentClause={},this.lexemeIdx=0}</span>,t.QueryParser.prototype.parse=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >this.lexer.run(),this.lexemes=this.lexer.lexemes;<span class="cstat-no" title="statement not covered" >f</span>or(var e=<span class="cstat-no" title="statement not covered" >t.QueryParser.parseClause;</span>e;)<span class="cstat-no" title="statement not covered" >e=e(this);<span class="cstat-no" title="statement not covered" >r</span></span>eturn this.query}</span>,t.QueryParser.prototype.peekLexeme=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.lexemes[this.lexemeIdx]}</span>,t.QueryParser.prototype.consumeLexeme=<span class="fstat-no" title="function not covered" >fu</span>nction(){var e=<span class="cstat-no" title="statement not covered" >this.peekLexeme();<span class="cstat-no" title="statement not covered" ></span>return this.lexemeIdx+=1,e}</span>,t.QueryParser.prototype.nextClause=<span class="fstat-no" title="function not covered" >fu</span>nction(){var e=<span class="cstat-no" title="statement not covered" >this.currentClause;<span class="cstat-no" title="statement not covered" ></span>this.query.clause(e),this.currentClause={}}</span>,t.QueryParser.parseClause=<span class="fstat-no" title="function not covered" >fu</span>nction(e){var r=<span class="cstat-no" title="statement not covered" >e.peekLexeme();<span class="cstat-no" title="statement not covered" ></span>if(r!=null)<span class="cstat-no" title="statement not covered" >switch(r.type){case t.QueryLexer.PRESENCE:<span class="cstat-no" title="statement not covered" >return t.QueryParser.parsePresence;c</span>ase t.QueryLexer.FIELD:<span class="cstat-no" title="statement not covered" >return t.QueryParser.parseField;c</span>ase t.QueryLexer.TERM:<span class="cstat-no" title="statement not covered" >return t.QueryParser.parseTerm;d</span>efault:var n=<span class="cstat-no" title="statement not covered" >"expected either a field or a term, found "+r.type;<span class="cstat-no" title="statement not covered" ></span>throw r.str.length&gt;=1&amp;&amp;(n+=" with value '"+r.str+"'"),new t.QueryParseError(n,r.start,r.end)}</span>}</span></span>,t.QueryParser.parsePresence=<span class="fstat-no" title="function not covered" >fu</span>nction(e){var r=<span class="cstat-no" title="statement not covered" >e.consumeLexeme();<span class="cstat-no" title="statement not covered" ></span>if(r!=null){<span class="cstat-no" title="statement not covered" >switch(r.str){case"-":<span class="cstat-no" title="statement not covered" >e.currentClause.presence=t.Query.presence.PROHIBITED;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"+":<span class="cstat-no" title="statement not covered" >e.currentClause.presence=t.Query.presence.REQUIRED;<span class="cstat-no" title="statement not covered" >b</span>reak;d</span>efault:var n=<span class="cstat-no" title="statement not covered" >"unrecognised presence operator'"+r.str+"'";<span class="cstat-no" title="statement not covered" ></span>throw new t.QueryParseError(n,r.start,r.end)}</span>v</span>ar i=<span class="cstat-no" title="statement not covered" >e.peekLexeme();<span class="cstat-no" title="statement not covered" ></span>if(i==null){var n=<span class="cstat-no" title="statement not covered" >"expecting term or field, found nothing";<span class="cstat-no" title="statement not covered" ></span>throw new t.QueryParseError(n,r.start,r.end)}<span class="cstat-no" title="statement not covered" ></span>s</span>witch(i.type){case t.QueryLexer.FIELD:<span class="cstat-no" title="statement not covered" >return t.QueryParser.parseField;c</span>ase t.QueryLexer.TERM:<span class="cstat-no" title="statement not covered" >return t.QueryParser.parseTerm;d</span>efault:var n=<span class="cstat-no" title="statement not covered" >"expecting term or field, found '"+i.type+"'";<span class="cstat-no" title="statement not covered" ></span>throw new t.QueryParseError(n,i.start,i.end)}</span>}</span>}</span>,t.QueryParser.parseField=<span class="fstat-no" title="function not covered" >fu</span>nction(e){var r=<span class="cstat-no" title="statement not covered" >e.consumeLexeme();<span class="cstat-no" title="statement not covered" ></span>if(r!=null){<span class="cstat-no" title="statement not covered" >if(e.query.allFields.indexOf(r.str)==-1){var n=<span class="cstat-no" title="statement not covered" >e.query.allFields.map(<span class="fstat-no" title="function not covered" >fu</span>nction(o){<span class="cstat-no" title="statement not covered" >return"'"+o+"'"}</span>).join(", "),</span>i=<span class="cstat-no" title="statement not covered" >"unrecognised field '"+r.str+"', possible fields: "+n;<span class="cstat-no" title="statement not covered" ></span>throw new t.QueryParseError(i,r.start,r.end)}<span class="cstat-no" title="statement not covered" ></span>e</span>.currentClause.fields=[r.str];v</span>ar s=<span class="cstat-no" title="statement not covered" >e.peekLexeme();<span class="cstat-no" title="statement not covered" ></span>if(s==null){var i=<span class="cstat-no" title="statement not covered" >"expecting term, found nothing";<span class="cstat-no" title="statement not covered" ></span>throw new t.QueryParseError(i,r.start,r.end)}<span class="cstat-no" title="statement not covered" ></span>s</span>witch(s.type){case t.QueryLexer.TERM:<span class="cstat-no" title="statement not covered" >return t.QueryParser.parseTerm;d</span>efault:var i=<span class="cstat-no" title="statement not covered" >"expecting term, found '"+s.type+"'";<span class="cstat-no" title="statement not covered" ></span>throw new t.QueryParseError(i,s.start,s.end)}</span>}</span>}</span>,t.QueryParser.parseTerm=<span class="fstat-no" title="function not covered" >fu</span>nction(e){var r=<span class="cstat-no" title="statement not covered" >e.consumeLexeme();<span class="cstat-no" title="statement not covered" ></span>if(r!=null){<span class="cstat-no" title="statement not covered" >e.currentClause.term=r.str.toLowerCase(),r.str.indexOf("*")!=-1&amp;&amp;(e.currentClause.usePipeline=!1);v</span>ar n=<span class="cstat-no" title="statement not covered" >e.peekLexeme();<span class="cstat-no" title="statement not covered" ></span>if(n==null){<span class="cstat-no" title="statement not covered" >e.nextClause();<span class="cstat-no" title="statement not covered" >r</span>eturn}<span class="cstat-no" title="statement not covered" ></span>s</span>witch(n.type){case t.QueryLexer.TERM:<span class="cstat-no" title="statement not covered" >return e.nextClause(),t.QueryParser.parseTerm;c</span>ase t.QueryLexer.FIELD:<span class="cstat-no" title="statement not covered" >return e.nextClause(),t.QueryParser.parseField;c</span>ase t.QueryLexer.EDIT_DISTANCE:<span class="cstat-no" title="statement not covered" >return t.QueryParser.parseEditDistance;c</span>ase t.QueryLexer.BOOST:<span class="cstat-no" title="statement not covered" >return t.QueryParser.parseBoost;c</span>ase t.QueryLexer.PRESENCE:<span class="cstat-no" title="statement not covered" >return e.nextClause(),t.QueryParser.parsePresence;d</span>efault:var i=<span class="cstat-no" title="statement not covered" >"Unexpected lexeme type '"+n.type+"'";<span class="cstat-no" title="statement not covered" ></span>throw new t.QueryParseError(i,n.start,n.end)}</span>}</span>}</span>,t.QueryParser.parseEditDistance=<span class="fstat-no" title="function not covered" >fu</span>nction(e){var r=<span class="cstat-no" title="statement not covered" >e.consumeLexeme();<span class="cstat-no" title="statement not covered" ></span>if(r!=null){var n=<span class="cstat-no" title="statement not covered" >parseInt(r.str,10);<span class="cstat-no" title="statement not covered" ></span>if(isNaN(n)){var i=<span class="cstat-no" title="statement not covered" >"edit distance must be numeric";<span class="cstat-no" title="statement not covered" ></span>throw new t.QueryParseError(i,r.start,r.end)}<span class="cstat-no" title="statement not covered" ></span>e</span>.currentClause.editDistance=n;v</span>ar s=<span class="cstat-no" title="statement not covered" >e.peekLexeme();<span class="cstat-no" title="statement not covered" ></span>if(s==null){<span class="cstat-no" title="statement not covered" >e.nextClause();<span class="cstat-no" title="statement not covered" >r</span>eturn}<span class="cstat-no" title="statement not covered" ></span>s</span>witch(s.type){case t.QueryLexer.TERM:<span class="cstat-no" title="statement not covered" >return e.nextClause(),t.QueryParser.parseTerm;c</span>ase t.QueryLexer.FIELD:<span class="cstat-no" title="statement not covered" >return e.nextClause(),t.QueryParser.parseField;c</span>ase t.QueryLexer.EDIT_DISTANCE:<span class="cstat-no" title="statement not covered" >return t.QueryParser.parseEditDistance;c</span>ase t.QueryLexer.BOOST:<span class="cstat-no" title="statement not covered" >return t.QueryParser.parseBoost;c</span>ase t.QueryLexer.PRESENCE:<span class="cstat-no" title="statement not covered" >return e.nextClause(),t.QueryParser.parsePresence;d</span>efault:var i=<span class="cstat-no" title="statement not covered" >"Unexpected lexeme type '"+s.type+"'";<span class="cstat-no" title="statement not covered" ></span>throw new t.QueryParseError(i,s.start,s.end)}</span>}</span>}</span>,t.QueryParser.parseBoost=<span class="fstat-no" title="function not covered" >fu</span>nction(e){var r=<span class="cstat-no" title="statement not covered" >e.consumeLexeme();<span class="cstat-no" title="statement not covered" ></span>if(r!=null){var n=<span class="cstat-no" title="statement not covered" >parseInt(r.str,10);<span class="cstat-no" title="statement not covered" ></span>if(isNaN(n)){var i=<span class="cstat-no" title="statement not covered" >"boost must be numeric";<span class="cstat-no" title="statement not covered" ></span>throw new t.QueryParseError(i,r.start,r.end)}<span class="cstat-no" title="statement not covered" ></span>e</span>.currentClause.boost=n;v</span>ar s=<span class="cstat-no" title="statement not covered" >e.peekLexeme();<span class="cstat-no" title="statement not covered" ></span>if(s==null){<span class="cstat-no" title="statement not covered" >e.nextClause();<span class="cstat-no" title="statement not covered" >r</span>eturn}<span class="cstat-no" title="statement not covered" ></span>s</span>witch(s.type){case t.QueryLexer.TERM:<span class="cstat-no" title="statement not covered" >return e.nextClause(),t.QueryParser.parseTerm;c</span>ase t.QueryLexer.FIELD:<span class="cstat-no" title="statement not covered" >return e.nextClause(),t.QueryParser.parseField;c</span>ase t.QueryLexer.EDIT_DISTANCE:<span class="cstat-no" title="statement not covered" >return t.QueryParser.parseEditDistance;c</span>ase t.QueryLexer.BOOST:<span class="cstat-no" title="statement not covered" >return t.QueryParser.parseBoost;c</span>ase t.QueryLexer.PRESENCE:<span class="cstat-no" title="statement not covered" >return e.nextClause(),t.QueryParser.parsePresence;d</span>efault:var i=<span class="cstat-no" title="statement not covered" >"Unexpected lexeme type '"+s.type+"'";<span class="cstat-no" title="statement not covered" ></span>throw new t.QueryParseError(i,s.start,s.end)}</span>}</span>}</span>,<span class="fstat-no" title="function not covered" >fu</span>nction(e,r){<span class="cstat-no" title="statement not covered" >typeof define=="function"&amp;&amp;define.amd?define(r):typeof de=="object"?fe.exports=r():e.lunr=r()}</span>(this,<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return t}</span>)}</span>)()});var ce=<span class="cstat-no" title="statement not covered" >[];</span>function <span class="fstat-no" title="function not covered" >N(</span>t,e){<span class="cstat-no" title="statement not covered" >ce.push({selector:e,constructor:t})}</span>var Y=<span class="cstat-no" title="statement not covered" >class{<span class="fstat-no" title="function not covered" >co</span>nstructor(){<span class="cstat-no" title="statement not covered" >this.createComponents(document.body)}<span class="fstat-no" title="function not covered" ></span>cr</span>eateComponents(e){<span class="cstat-no" title="statement not covered" >ce.forEach(<span class="fstat-no" title="function not covered" >r=</span>&gt;{<span class="cstat-no" title="statement not covered" >e.querySelectorAll(r.selector).forEach(<span class="fstat-no" title="function not covered" >n=</span>&gt;{<span class="cstat-no" title="statement not covered" >n.dataset.hasInstance||(new r.constructor({el:n}),n.dataset.hasInstance=String(!0))}</span>)}</span>)}</span>};</span>var k=<span class="cstat-no" title="statement not covered" >class{<span class="fstat-no" title="function not covered" >co</span>nstructor(e){<span class="cstat-no" title="statement not covered" >this.el=e.el}</span>};</span>var J=<span class="cstat-no" title="statement not covered" >class{<span class="fstat-no" title="function not covered" >co</span>nstructor(){<span class="cstat-no" title="statement not covered" >this.listeners={}}<span class="fstat-no" title="function not covered" ></span>ad</span>dEventListener(e,r){<span class="cstat-no" title="statement not covered" >e in this.listeners||(this.listeners[e]=[]),this.listeners[e].push(r)}<span class="fstat-no" title="function not covered" ></span>re</span>moveEventListener(e,r){<span class="cstat-no" title="statement not covered" >if(!(e in this.listeners))<span class="cstat-no" title="statement not covered" >return;l</span></span>et n=<span class="cstat-no" title="statement not covered" >this.listeners[e];<span class="cstat-no" title="statement not covered" ></span>for(let i=<span class="cstat-no" title="statement not covered" >0,</span>s=<span class="cstat-no" title="statement not covered" >n.length;</span>i&lt;s;i++)<span class="cstat-no" title="statement not covered" >if(n[i]===r){<span class="cstat-no" title="statement not covered" >n.splice(i,1);<span class="cstat-no" title="statement not covered" >r</span>eturn}</span>}<span class="fstat-no" title="function not covered" ></span></span>di</span>spatchEvent(e){<span class="cstat-no" title="statement not covered" >if(!(e.type in this.listeners))<span class="cstat-no" title="statement not covered" >return!0;l</span></span>et r=<span class="cstat-no" title="statement not covered" >this.listeners[e.type].slice();<span class="cstat-no" title="statement not covered" ></span>for(let n=<span class="cstat-no" title="statement not covered" >0,</span>i=<span class="cstat-no" title="statement not covered" >r.length;</span>n&lt;i;n++)<span class="cstat-no" title="statement not covered" >r[n].call(this,e);<span class="cstat-no" title="statement not covered" >r</span></span>eturn!e.defaultPrevented}</span>};</span>var ne=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e=<span class="branch-0 cbranch-no" title="branch not covered" >100)</span>=&gt;{let r=<span class="cstat-no" title="statement not covered" >Date.now();<span class="cstat-no" title="statement not covered" ></span>return<span class="fstat-no" title="function not covered" >(.</span>..n)=&gt;{<span class="cstat-no" title="statement not covered" >r+e-Date.now()&lt;0&amp;&amp;(t(...n),r=Date.now())}</span>}</span>;</span>var ie=<span class="cstat-no" title="statement not covered" >class extends J{<span class="fstat-no" title="function not covered" >co</span>nstructor(){<span class="cstat-no" title="statement not covered" >super();<span class="cstat-no" title="statement not covered" >t</span>his.scrollTop=0;<span class="cstat-no" title="statement not covered" >t</span>his.lastY=0;<span class="cstat-no" title="statement not covered" >t</span>his.width=0;<span class="cstat-no" title="statement not covered" >t</span>his.height=0;<span class="cstat-no" title="statement not covered" >t</span>his.showToolbar=!0;<span class="cstat-no" title="statement not covered" >t</span>his.toolbar=document.querySelector(".tsd-page-toolbar"),this.secondaryNav=document.querySelector(".tsd-navigation.secondary"),window.addEventListener("scroll",ne(<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >this.onScroll(),</span>10)),window.addEventListener("resize",ne(<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >this.onResize(),</span>10)),this.onResize(),this.onScroll()}<span class="fstat-no" title="function not covered" ></span>tr</span>iggerResize(){let r=<span class="cstat-no" title="statement not covered" >new CustomEvent("resize",{detail:{width:this.width,height:this.height}});<span class="cstat-no" title="statement not covered" ></span>this.dispatchEvent(r)}<span class="fstat-no" title="function not covered" ></span>on</span>Resize(){<span class="cstat-no" title="statement not covered" >this.width=window.innerWidth||0,this.height=window.innerHeight||0;l</span>et r=<span class="cstat-no" title="statement not covered" >new CustomEvent("resize",{detail:{width:this.width,height:this.height}});<span class="cstat-no" title="statement not covered" ></span>this.dispatchEvent(r)}<span class="fstat-no" title="function not covered" ></span>on</span>Scroll(){<span class="cstat-no" title="statement not covered" >this.scrollTop=window.scrollY||0;l</span>et r=<span class="cstat-no" title="statement not covered" >new CustomEvent("scroll",{detail:{scrollTop:this.scrollTop}});<span class="cstat-no" title="statement not covered" ></span>this.dispatchEvent(r),this.hideShowToolbar()}<span class="fstat-no" title="function not covered" ></span>hi</span>deShowToolbar(){var n;let r=<span class="cstat-no" title="statement not covered" >this.showToolbar;<span class="cstat-no" title="statement not covered" ></span>this.showToolbar=this.lastY&gt;=this.scrollTop||this.scrollTop&lt;=0,r!==this.showToolbar&amp;&amp;(this.toolbar.classList.toggle("tsd-page-toolbar--hide"),(n=this.secondaryNav)==null||n.classList.toggle("tsd-navigation--toolbar-hide")),this.lastY=this.scrollTop}</span>},</span>Q=<span class="cstat-no" title="statement not covered" >ie;<span class="cstat-no" title="statement not covered" ></span>Q.instance=new ie;v</span>ar X=<span class="cstat-no" title="statement not covered" >class extends k{<span class="fstat-no" title="function not covered" >co</span>nstructor(r){<span class="cstat-no" title="statement not covered" >super(r);<span class="cstat-no" title="statement not covered" >t</span>his.anchors=[];<span class="cstat-no" title="statement not covered" >t</span>his.index=-1;<span class="cstat-no" title="statement not covered" >Q</span>.instance.addEventListener("resize",<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >this.onResize())</span>,Q.instance.addEventListener("scroll",<span class="fstat-no" title="function not covered" >n=</span>&gt;<span class="cstat-no" title="statement not covered" >this.onScroll(n))</span>,this.createAnchors()}<span class="fstat-no" title="function not covered" ></span>cr</span>eateAnchors(){let r=<span class="cstat-no" title="statement not covered" >window.location.href;<span class="cstat-no" title="statement not covered" ></span>r.indexOf("#")!=-1&amp;&amp;(r=r.substr(0,r.indexOf("#"))),this.el.querySelectorAll("a").forEach(<span class="fstat-no" title="function not covered" >n=</span>&gt;{let i=<span class="cstat-no" title="statement not covered" >n.href;<span class="cstat-no" title="statement not covered" ></span>if(i.indexOf("#")==-1||i.substr(0,r.length)!=r)<span class="cstat-no" title="statement not covered" >return;l</span></span>et s=<span class="cstat-no" title="statement not covered" >i.substr(i.indexOf("#")+1),</span>o=<span class="cstat-no" title="statement not covered" >document.querySelector("a.tsd-anchor[name="+s+"]"),</span>a=<span class="cstat-no" title="statement not covered" >n.parentNode;<span class="cstat-no" title="statement not covered" ></span>!o||!a||this.anchors.push({link:a,anchor:o,position:0})}</span>),this.onResize()}<span class="fstat-no" title="function not covered" ></span>on</span>Resize(){let r;<span class="cstat-no" title="statement not covered" >for(let i=<span class="cstat-no" title="statement not covered" >0,</span>s=<span class="cstat-no" title="statement not covered" >this.anchors.length;</span>i&lt;s;i++){<span class="cstat-no" title="statement not covered" >r=this.anchors[i];l</span>et o=<span class="cstat-no" title="statement not covered" >r.anchor.getBoundingClientRect();<span class="cstat-no" title="statement not covered" ></span>r.position=o.top+document.body.scrollTop}<span class="cstat-no" title="statement not covered" ></span>t</span>his.anchors.sort(<span class="fstat-no" title="function not covered" >(i</span>,s)=&gt;<span class="cstat-no" title="statement not covered" >i.position-s.position)</span>;l</span>et n=<span class="cstat-no" title="statement not covered" >new CustomEvent("scroll",{detail:{scrollTop:Q.instance.scrollTop}});<span class="cstat-no" title="statement not covered" ></span>this.onScroll(n)}<span class="fstat-no" title="function not covered" ></span>on</span>Scroll(r){let n=<span class="cstat-no" title="statement not covered" >r.detail.scrollTop+5,</span>i=<span class="cstat-no" title="statement not covered" >this.anchors,</span>s=<span class="cstat-no" title="statement not covered" >i.length-1,</span>o=<span class="cstat-no" title="statement not covered" >this.index;<span class="cstat-no" title="statement not covered" ></span>for(;o&gt;-1&amp;&amp;i[o].position&gt;n;)<span class="cstat-no" title="statement not covered" >o-=1;<span class="cstat-no" title="statement not covered" >f</span></span>or(;o&lt;s&amp;&amp;i[o+1].position&lt;n;)<span class="cstat-no" title="statement not covered" >o+=1;<span class="cstat-no" title="statement not covered" >t</span></span>his.index!=o&amp;&amp;(this.index&gt;-1&amp;&amp;this.anchors[this.index].link.classList.remove("focus"),this.index=o,this.index&gt;-1&amp;&amp;this.anchors[this.index].link.classList.add("focus"))}</span>};</span>var he=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e=<span class="branch-0 cbranch-no" title="branch not covered" >100)</span>=&gt;{let r;<span class="cstat-no" title="statement not covered" >return<span class="fstat-no" title="function not covered" >(.</span>..n)=&gt;{<span class="cstat-no" title="statement not covered" >clearTimeout(r),r=setTimeout(<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >t(n),</span>e)}</span>}</span>;</span>var ge=<span class="cstat-no" title="statement not covered" >Fe(pe());</span>function <span class="fstat-no" title="function not covered" >ye(</span>){let t=<span class="cstat-no" title="statement not covered" >document.getElementById("tsd-search");<span class="cstat-no" title="statement not covered" ></span>if(!t)<span class="cstat-no" title="statement not covered" >return;l</span></span>et e=<span class="cstat-no" title="statement not covered" >document.getElementById("search-script");<span class="cstat-no" title="statement not covered" ></span>t.classList.add("loading"),e&amp;&amp;(e.addEventListener("error",<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >t.classList.remove("loading"),t.classList.add("failure")}</span>),e.addEventListener("load",<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >t.classList.remove("loading"),t.classList.add("ready")}</span>),window.searchData&amp;&amp;t.classList.remove("loading"));l</span>et r=<span class="cstat-no" title="statement not covered" >document.querySelector("#tsd-search input"),</span>n=<span class="cstat-no" title="statement not covered" >document.querySelector("#tsd-search .results");<span class="cstat-no" title="statement not covered" ></span>if(!r||!n)<span class="cstat-no" title="statement not covered" >throw new Error("The input field or the result list wrapper was not found");l</span></span>et i=<span class="cstat-no" title="statement not covered" >!1;<span class="cstat-no" title="statement not covered" ></span>n.addEventListener("mousedown",<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >i=!0)</span>,n.addEventListener("mouseup",<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >i=!1,t.classList.remove("has-focus")}</span>),r.addEventListener("focus",<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >t.classList.add("has-focus"))</span>,r.addEventListener("blur",<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >i||(i=!1,t.classList.remove("has-focus"))}</span>);l</span>et s=<span class="cstat-no" title="statement not covered" >{base:t.dataset.base+"/"};<span class="cstat-no" title="statement not covered" ></span>Ae(t,n,r,s)}</span>function <span class="fstat-no" title="function not covered" >Ae(</span>t,e,r,n){<span class="cstat-no" title="statement not covered" >r.addEventListener("input",he(<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >He(t,e,r,n)}</span>,200));l</span>et i=<span class="cstat-no" title="statement not covered" >!1;<span class="cstat-no" title="statement not covered" ></span>r.addEventListener("keydown",<span class="fstat-no" title="function not covered" >s=</span>&gt;{<span class="cstat-no" title="statement not covered" >i=!0,s.key=="Enter"?ze(e,r):s.key=="Escape"?r.blur():s.key=="ArrowUp"?me(e,-1):s.key==="ArrowDown"?me(e,1):i=!1}</span>),r.addEventListener("keypress",<span class="fstat-no" title="function not covered" >s=</span>&gt;{<span class="cstat-no" title="statement not covered" >i&amp;&amp;s.preventDefault()}</span>),document.body.addEventListener("keydown",<span class="fstat-no" title="function not covered" >s=</span>&gt;{<span class="cstat-no" title="statement not covered" >s.altKey||s.ctrlKey||s.metaKey||!r.matches(":focus")&amp;&amp;s.key==="/"&amp;&amp;(r.focus(),s.preventDefault())}</span>)}</span>function <span class="fstat-no" title="function not covered" >Ve(</span>t,e){<span class="cstat-no" title="statement not covered" >t.index||window.searchData&amp;&amp;(e.classList.remove("loading"),e.classList.add("ready"),t.data=window.searchData,t.index=ge.Index.load(window.searchData.index))}</span>function <span class="fstat-no" title="function not covered" >He(</span>t,e,r,n){<span class="cstat-no" title="statement not covered" >if(Ve(n,t),!n.index||!n.data)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >e</span></span>.textContent="";l</span>et i=<span class="cstat-no" title="statement not covered" >r.value.trim(),</span>s=<span class="cstat-no" title="statement not covered" >i?n.index.search(`*${i}*`):[];<span class="cstat-no" title="statement not covered" ></span>for(let o=<span class="cstat-no" title="statement not covered" >0,</span>a=<span class="cstat-no" title="statement not covered" >Math.min(10,s.length);</span>o&lt;a;o++){let u=<span class="cstat-no" title="statement not covered" >n.data.rows[Number(s[o].ref)],</span>l=<span class="cstat-no" title="statement not covered" >ve(u.name,i);<span class="cstat-no" title="statement not covered" ></span>u.parent&amp;&amp;(l=`&lt;span class="parent"&gt;${ve(u.parent,i)}.&lt;/span&gt;${l}`);l</span>et h=<span class="cstat-no" title="statement not covered" >document.createElement("li");<span class="cstat-no" title="statement not covered" ></span>h.classList.value=u.classes;l</span>et p=<span class="cstat-no" title="statement not covered" >document.createElement("a");<span class="cstat-no" title="statement not covered" ></span>p.href=n.base+u.url,p.classList.add("tsd-kind-icon"),p.innerHTML=l,h.append(p),e.appendChild(h)}</span>}</span>function <span class="fstat-no" title="function not covered" >me(</span>t,e){let r=<span class="cstat-no" title="statement not covered" >t.querySelector(".current");<span class="cstat-no" title="statement not covered" ></span>if(!r)<span class="cstat-no" title="statement not covered" >r=t.querySelector(e==1?"li:first-child":"li:last-child"),r&amp;&amp;r.classList.add("current");e</span>lse{let n=<span class="cstat-no" title="statement not covered" >r;<span class="cstat-no" title="statement not covered" ></span>if(e===1)<span class="cstat-no" title="statement not covered" >do <span class="cstat-no" title="statement not covered" >n=n.nextElementSibling;w</span>hile(n instanceof HTMLElement&amp;&amp;n.offsetParent==null);e</span>lse <span class="cstat-no" title="statement not covered" >do <span class="cstat-no" title="statement not covered" >n=n.previousElementSibling;w</span>hile(n instanceof HTMLElement&amp;&amp;n.offsetParent==null);<span class="cstat-no" title="statement not covered" >n</span></span>&amp;&amp;(r.classList.remove("current"),n.classList.add("current"))}</span>}</span>function <span class="fstat-no" title="function not covered" >ze(</span>t,e){let r=<span class="cstat-no" title="statement not covered" >t.querySelector(".current");<span class="cstat-no" title="statement not covered" ></span>if(r||(r=t.querySelector("li:first-child")),r){let n=<span class="cstat-no" title="statement not covered" >r.querySelector("a");<span class="cstat-no" title="statement not covered" ></span>n&amp;&amp;(window.location.href=n.href),e.blur()}</span>}</span>function <span class="fstat-no" title="function not covered" >ve(</span>t,e){<span class="cstat-no" title="statement not covered" >if(e==="")<span class="cstat-no" title="statement not covered" >return t;l</span></span>et r=<span class="cstat-no" title="statement not covered" >t.toLocaleLowerCase(),</span>n=<span class="cstat-no" title="statement not covered" >e.toLocaleLowerCase(),</span>i=<span class="cstat-no" title="statement not covered" >[],</span>s=<span class="cstat-no" title="statement not covered" >0,</span>o=<span class="cstat-no" title="statement not covered" >r.indexOf(n);<span class="cstat-no" title="statement not covered" ></span>for(;o!=-1;)<span class="cstat-no" title="statement not covered" >i.push(se(t.substring(s,o)),`&lt;b&gt;${se(t.substring(o,o+n.length))}&lt;/b&gt;`),s=o+n.length,o=r.indexOf(n,s);<span class="cstat-no" title="statement not covered" >r</span></span>eturn i.push(se(t.substring(s))),i.join("")}</span>var Ne=<span class="cstat-no" title="statement not covered" >{"&amp;":"&amp;amp;","&lt;":"&amp;lt;","&gt;":"&amp;gt;","'":"&amp;#039;",'"':"&amp;quot;"};</span>function <span class="fstat-no" title="function not covered" >se(</span>t){<span class="cstat-no" title="statement not covered" >return t.replace(/[&amp;&lt;&gt;"'"]/g,<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >Ne[e])</span>}</span>var oe=<span class="cstat-no" title="statement not covered" >class{<span class="fstat-no" title="function not covered" >co</span>nstructor(e,r){<span class="cstat-no" title="statement not covered" >this.signature=e,this.description=r}<span class="fstat-no" title="function not covered" ></span>ad</span>dClass(e){<span class="cstat-no" title="statement not covered" >return this.signature.classList.add(e),this.description.classList.add(e),this}<span class="fstat-no" title="function not covered" ></span>re</span>moveClass(e){<span class="cstat-no" title="statement not covered" >return this.signature.classList.remove(e),this.description.classList.remove(e),this}</span>},</span>Z=<span class="cstat-no" title="statement not covered" >class extends k{<span class="fstat-no" title="function not covered" >co</span>nstructor(r){<span class="cstat-no" title="statement not covered" >super(r);<span class="cstat-no" title="statement not covered" >t</span>his.groups=[];<span class="cstat-no" title="statement not covered" >t</span>his.index=-1;<span class="cstat-no" title="statement not covered" >t</span>his.createGroups(),this.container&amp;&amp;(this.el.classList.add("active"),Array.from(this.el.children).forEach(<span class="fstat-no" title="function not covered" >n=</span>&gt;{<span class="cstat-no" title="statement not covered" >n.addEventListener("touchstart",<span class="fstat-no" title="function not covered" >i=</span>&gt;<span class="cstat-no" title="statement not covered" >this.onClick(i))</span>,n.addEventListener("click",<span class="fstat-no" title="function not covered" >i=</span>&gt;<span class="cstat-no" title="statement not covered" >this.onClick(i))</span>}</span>),this.container.classList.add("active"),this.setIndex(0))}<span class="fstat-no" title="function not covered" ></span>se</span>tIndex(r){<span class="cstat-no" title="statement not covered" >if(r&lt;0&amp;&amp;(r=0),r&gt;this.groups.length-1&amp;&amp;(r=this.groups.length-1),this.index==r)<span class="cstat-no" title="statement not covered" >return;l</span></span>et n=<span class="cstat-no" title="statement not covered" >this.groups[r];<span class="cstat-no" title="statement not covered" ></span>if(this.index&gt;-1){let i=<span class="cstat-no" title="statement not covered" >this.groups[this.index];<span class="cstat-no" title="statement not covered" ></span>i.removeClass("current").addClass("fade-out"),n.addClass("current"),n.addClass("fade-in"),Q.instance.triggerResize(),setTimeout(<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >i.removeClass("fade-out"),n.removeClass("fade-in")}</span>,300)}</span>else <span class="cstat-no" title="statement not covered" >n.addClass("current"),Q.instance.triggerResize();<span class="cstat-no" title="statement not covered" >t</span></span>his.index=r}<span class="fstat-no" title="function not covered" ></span>cr</span>eateGroups(){let r=<span class="cstat-no" title="statement not covered" >this.el.children;<span class="cstat-no" title="statement not covered" ></span>if(r.length&lt;2)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span></span>his.container=this.el.nextElementSibling;l</span>et n=<span class="cstat-no" title="statement not covered" >this.container.children;<span class="cstat-no" title="statement not covered" ></span>this.groups=[];<span class="cstat-no" title="statement not covered" >f</span>or(let i=<span class="cstat-no" title="statement not covered" >0;</span>i&lt;r.length;i++)<span class="cstat-no" title="statement not covered" >this.groups.push(new oe(r[i],n[i]))}<span class="fstat-no" title="function not covered" ></span></span>on</span>Click(r){<span class="cstat-no" title="statement not covered" >this.groups.forEach(<span class="fstat-no" title="function not covered" >(n</span>,i)=&gt;{<span class="cstat-no" title="statement not covered" >n.signature===r.currentTarget&amp;&amp;this.setIndex(i)}</span>)}</span>};</span>var C=<span class="cstat-no" title="statement not covered" >"mousedown",</span>Le=<span class="cstat-no" title="statement not covered" >"mousemove",</span>_=<span class="cstat-no" title="statement not covered" >"mouseup",</span>K=<span class="cstat-no" title="statement not covered" >{x:0,y:0},</span>xe=<span class="cstat-no" title="statement not covered" >!1,</span>ae=<span class="cstat-no" title="statement not covered" >!1,</span>je=<span class="cstat-no" title="statement not covered" >!1,</span>A=<span class="cstat-no" title="statement not covered" >!1,</span>Ee=<span class="cstat-no" title="statement not covered" >/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);<span class="cstat-no" title="statement not covered" ></span>document.documentElement.classList.add(Ee?"is-mobile":"not-mobile");<span class="cstat-no" title="statement not covered" >E</span>e&amp;&amp;"ontouchstart"in document.documentElement&amp;&amp;(je=!0,C="touchstart",Le="touchmove",_="touchend");<span class="cstat-no" title="statement not covered" >d</span>ocument.addEventListener(C,<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >ae=!0,A=!1;l</span>et e=<span class="cstat-no" title="statement not covered" >C=="touchstart"?t.targetTouches[0]:t;<span class="cstat-no" title="statement not covered" ></span>K.y=e.pageY||0,K.x=e.pageX||0}</span>);<span class="cstat-no" title="statement not covered" >d</span>ocument.addEventListener(Le,<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >if(!!ae&amp;&amp;!A){let e=<span class="cstat-no" title="statement not covered" >C=="touchstart"?t.targetTouches[0]:t,</span>r=<span class="cstat-no" title="statement not covered" >K.x-(e.pageX||0),</span>n=<span class="cstat-no" title="statement not covered" >K.y-(e.pageY||0);<span class="cstat-no" title="statement not covered" ></span>A=Math.sqrt(r*r+n*n)&gt;10}</span>}</span>);<span class="cstat-no" title="statement not covered" >d</span>ocument.addEventListener(_,<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >ae=!1}</span>);<span class="cstat-no" title="statement not covered" >d</span>ocument.addEventListener("click",<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >xe&amp;&amp;(t.preventDefault(),t.stopImmediatePropagation(),xe=!1)}</span>);v</span>ar ee=<span class="cstat-no" title="statement not covered" >class extends k{<span class="fstat-no" title="function not covered" >co</span>nstructor(r){<span class="cstat-no" title="statement not covered" >super(r);<span class="cstat-no" title="statement not covered" >t</span>his.className=this.el.dataset.toggle||"",this.el.addEventListener(_,<span class="fstat-no" title="function not covered" >n=</span>&gt;<span class="cstat-no" title="statement not covered" >this.onPointerUp(n))</span>,this.el.addEventListener("click",<span class="fstat-no" title="function not covered" >n=</span>&gt;<span class="cstat-no" title="statement not covered" >n.preventDefault())</span>,document.addEventListener(C,<span class="fstat-no" title="function not covered" >n=</span>&gt;<span class="cstat-no" title="statement not covered" >this.onDocumentPointerDown(n))</span>,document.addEventListener(_,<span class="fstat-no" title="function not covered" >n=</span>&gt;<span class="cstat-no" title="statement not covered" >this.onDocumentPointerUp(n))</span>}<span class="fstat-no" title="function not covered" ></span>se</span>tActive(r){<span class="cstat-no" title="statement not covered" >if(this.active==r)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span></span>his.active=r,document.documentElement.classList.toggle("has-"+this.className,r),this.el.classList.toggle("active",r);l</span>et n=<span class="cstat-no" title="statement not covered" >(this.active?"to-has-":"from-has-")+this.className;<span class="cstat-no" title="statement not covered" ></span>document.documentElement.classList.add(n),setTimeout(<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >document.documentElement.classList.remove(n),</span>500)}<span class="fstat-no" title="function not covered" ></span>on</span>PointerUp(r){<span class="cstat-no" title="statement not covered" >A||(this.setActive(!0),r.preventDefault())}<span class="fstat-no" title="function not covered" ></span>on</span>DocumentPointerDown(r){<span class="cstat-no" title="statement not covered" >if(this.active){<span class="cstat-no" title="statement not covered" >if(r.target.closest(".col-menu, .tsd-filter-group"))<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span></span>his.setActive(!1)}</span>}<span class="fstat-no" title="function not covered" ></span>on</span>DocumentPointerUp(r){<span class="cstat-no" title="statement not covered" >if(!A&amp;&amp;this.active&amp;&amp;r.target.closest(".col-menu")){let n=<span class="cstat-no" title="statement not covered" >r.target.closest("a");<span class="cstat-no" title="statement not covered" ></span>if(n){let i=<span class="cstat-no" title="statement not covered" >window.location.href;<span class="cstat-no" title="statement not covered" ></span>i.indexOf("#")!=-1&amp;&amp;(i=i.substr(0,i.indexOf("#"))),n.href.substr(0,i.length)==i&amp;&amp;setTimeout(<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >this.setActive(!1),</span>250)}</span>}</span>}</span>};</span>var te=<span class="cstat-no" title="statement not covered" >class{<span class="fstat-no" title="function not covered" >co</span>nstructor(e,r){<span class="cstat-no" title="statement not covered" >this.key=e,this.value=r,this.defaultValue=r,this.initialize(),window.localStorage[this.key]&amp;&amp;this.setValue(this.fromLocalStorage(window.localStorage[this.key]))}<span class="fstat-no" title="function not covered" ></span>in</span>itialize(){}<span class="fstat-no" title="function not covered" >se</span>tValue(e){<span class="cstat-no" title="statement not covered" >if(this.value==e)<span class="cstat-no" title="statement not covered" >return;l</span></span>et r=<span class="cstat-no" title="statement not covered" >this.value;<span class="cstat-no" title="statement not covered" ></span>this.value=e,window.localStorage[this.key]=this.toLocalStorage(e),this.handleValueChange(r,e)}</span>},</span>re=<span class="cstat-no" title="statement not covered" >class extends te{<span class="fstat-no" title="function not covered" >in</span>itialize(){let r=<span class="cstat-no" title="statement not covered" >document.querySelector("#tsd-filter-"+this.key);<span class="cstat-no" title="statement not covered" ></span>!r||(this.checkbox=r,this.checkbox.addEventListener("change",<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >this.setValue(this.checkbox.checked)}</span>))}<span class="fstat-no" title="function not covered" ></span>ha</span>ndleValueChange(r,n){<span class="cstat-no" title="statement not covered" >!this.checkbox||(this.checkbox.checked=this.value,document.documentElement.classList.toggle("toggle-"+this.key,this.value!=this.defaultValue))}<span class="fstat-no" title="function not covered" ></span>fr</span>omLocalStorage(r){<span class="cstat-no" title="statement not covered" >return r=="true"}<span class="fstat-no" title="function not covered" ></span>to</span>LocalStorage(r){<span class="cstat-no" title="statement not covered" >return r?"true":"false"}</span>},</span>le=<span class="cstat-no" title="statement not covered" >class extends te{<span class="fstat-no" title="function not covered" >in</span>itialize(){<span class="cstat-no" title="statement not covered" >document.documentElement.classList.add("toggle-"+this.key+this.value);l</span>et r=<span class="cstat-no" title="statement not covered" >document.querySelector("#tsd-filter-"+this.key);<span class="cstat-no" title="statement not covered" ></span>if(!r)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span></span>his.select=r;l</span>et n=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >this.select.classList.add("active")}</span>,</span>i=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >this.select.classList.remove("active")}</span>;<span class="cstat-no" title="statement not covered" ></span>this.select.addEventListener(C,n),this.select.addEventListener("mouseover",n),this.select.addEventListener("mouseleave",i),this.select.querySelectorAll("li").forEach(<span class="fstat-no" title="function not covered" >s=</span>&gt;{<span class="cstat-no" title="statement not covered" >s.addEventListener(_,<span class="fstat-no" title="function not covered" >o=</span>&gt;{<span class="cstat-no" title="statement not covered" >r.classList.remove("active"),this.setValue(o.target.dataset.value||"")}</span>)}</span>),document.addEventListener(C,<span class="fstat-no" title="function not covered" >s=</span>&gt;{<span class="cstat-no" title="statement not covered" >this.select.contains(s.target)||this.select.classList.remove("active")}</span>)}<span class="fstat-no" title="function not covered" ></span>ha</span>ndleValueChange(r,n){<span class="cstat-no" title="statement not covered" >this.select.querySelectorAll("li.selected").forEach(<span class="fstat-no" title="function not covered" >o=</span>&gt;{<span class="cstat-no" title="statement not covered" >o.classList.remove("selected")}</span>);l</span>et i=<span class="cstat-no" title="statement not covered" >this.select.querySelector('li[data-value="'+n+'"]'),</span>s=<span class="cstat-no" title="statement not covered" >this.select.querySelector(".tsd-select-label");<span class="cstat-no" title="statement not covered" ></span>i&amp;&amp;s&amp;&amp;(i.classList.add("selected"),s.textContent=i.textContent),document.documentElement.classList.remove("toggle-"+r),document.documentElement.classList.add("toggle-"+n)}<span class="fstat-no" title="function not covered" ></span>fr</span>omLocalStorage(r){<span class="cstat-no" title="statement not covered" >return r}<span class="fstat-no" title="function not covered" ></span>to</span>LocalStorage(r){<span class="cstat-no" title="statement not covered" >return r}</span>},</span>j=<span class="cstat-no" title="statement not covered" >class extends k{<span class="fstat-no" title="function not covered" >co</span>nstructor(r){<span class="cstat-no" title="statement not covered" >super(r);<span class="cstat-no" title="statement not covered" >t</span>his.optionVisibility=new le("visibility","private"),this.optionInherited=new re("inherited",!0),this.optionExternals=new re("externals",!0)}<span class="fstat-no" title="function not covered" ></span>st</span>atic isSupported(){<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >return typeof window.localStorage!="undefined"}</span>catch{<span class="cstat-no" title="statement not covered" >return!1}</span>}</span>};</span>function <span class="fstat-no" title="function not covered" >we(</span>t){let e=<span class="cstat-no" title="statement not covered" >localStorage.getItem("tsd-theme")||"os";<span class="cstat-no" title="statement not covered" ></span>t.value=e,be(e),t.addEventListener("change",<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >localStorage.setItem("tsd-theme",t.value),be(t.value)}</span>)}</span>function <span class="fstat-no" title="function not covered" >be(</span>t){<span class="cstat-no" title="statement not covered" >switch(t){case"os":<span class="cstat-no" title="statement not covered" >document.body.classList.remove("light","dark");<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"light":<span class="cstat-no" title="statement not covered" >document.body.classList.remove("dark"),document.body.classList.add("light");<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"dark":<span class="cstat-no" title="statement not covered" >document.body.classList.remove("light"),document.body.classList.add("dark");<span class="cstat-no" title="statement not covered" >b</span>reak}</span>}<span class="cstat-no" title="statement not covered" ></span>ye();<span class="cstat-no" title="statement not covered" >N</span>(X,".menu-highlight");<span class="cstat-no" title="statement not covered" >N</span>(Z,".tsd-signatures");<span class="cstat-no" title="statement not covered" >N</span>(ee,"a[data-toggle]");<span class="cstat-no" title="statement not covered" >j</span>.isSupported()?N(j,"#tsd-filter"):document.documentElement.classList.add("no-filter");v</span>ar Te=<span class="cstat-no" title="statement not covered" >document.getElementById("theme");<span class="cstat-no" title="statement not covered" ></span>Te&amp;&amp;we(Te);v</span>ar Be=<span class="cstat-no" title="statement not covered" >new Y;<span class="cstat-no" title="statement not covered" ></span>Object.defineProperty(window,"app",{value:Be});}</span>)();
/*!
 * lunr.Builder
 * Copyright (C) 2020 Oliver Nightingale
 */
/*!
 * lunr.Index
 * Copyright (C) 2020 Oliver Nightingale
 */
/*!
 * lunr.Pipeline
 * Copyright (C) 2020 Oliver Nightingale
 */
/*!
 * lunr.Set
 * Copyright (C) 2020 Oliver Nightingale
 */
/*!
 * lunr.TokenSet
 * Copyright (C) 2020 Oliver Nightingale
 */
/*!
 * lunr.Vector
 * Copyright (C) 2020 Oliver Nightingale
 */
/*!
 * lunr.stemmer
 * Copyright (C) 2020 Oliver Nightingale
 * Includes code from - http://tartarus.org/~martin/PorterStemmer/js.txt
 */
/*!
 * lunr.stopWordFilter
 * Copyright (C) 2020 Oliver Nightingale
 */
/*!
 * lunr.tokenizer
 * Copyright (C) 2020 Oliver Nightingale
 */
/*!
 * lunr.trimmer
 * Copyright (C) 2020 Oliver Nightingale
 */
/*!
 * lunr.utils
 * Copyright (C) 2020 Oliver Nightingale
 */
/**
 * lunr - http://lunrjs.com - A bit like Solr, but much smaller and not as bright - 2.3.9
 * Copyright (C) 2020 Oliver Nightingale
 * @license MIT
 */
&nbsp;</pre></td></tr></table></pre>

                <div class='push'></div><!-- for sticky footer -->
            </div><!-- /wrapper -->
            <div class='footer quiet pad2 space-top1 center small'>
                Code coverage generated by
                <a href="https://istanbul.js.org/" target="_blank">istanbul</a>
                at Tue Jun 28 2022 13:15:48 GMT+0200 (Mitteleuropische Sommerzeit)
            </div>
        </div>
        <script src="../../prettify.js"></script>
        <script>
            window.onload = function () {
                prettyPrint();
            };
        </script>
        <script src="../../sorter.js"></script>
        <script src="../../block-navigation.js"></script>
    </body>
</html>
    