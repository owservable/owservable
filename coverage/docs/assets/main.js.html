
<!doctype html>
<html lang="en">

<head>
    <title>Code coverage report for docs/assets/main.js</title>
    <meta charset="utf-8" />
    <link rel="stylesheet" href="../../prettify.css" />
    <link rel="stylesheet" href="../../base.css" />
    <link rel="shortcut icon" type="image/x-icon" href="../../favicon.png" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style type='text/css'>
        .coverage-summary .sorter {
            background-image: url(../../sort-arrow-sprite.png);
        }
    </style>
</head>
    
<body>
<div class='wrapper'>
    <div class='pad1'>
        <h1><a href="../../index.html">All files</a> / <a href="index.html">docs/assets</a> main.js</h1>
        <div class='clearfix'>
            
            <div class='fl pad1y space-right2'>
                <span class="strong">0% </span>
                <span class="quiet">Statements</span>
                <span class='fraction'>0/1057</span>
            </div>
        
            
            <div class='fl pad1y space-right2'>
                <span class="strong">0% </span>
                <span class="quiet">Branches</span>
                <span class='fraction'>0/643</span>
            </div>
        
            
            <div class='fl pad1y space-right2'>
                <span class="strong">0% </span>
                <span class="quiet">Functions</span>
                <span class='fraction'>0/233</span>
            </div>
        
            
            <div class='fl pad1y space-right2'>
                <span class="strong">0% </span>
                <span class="quiet">Lines</span>
                <span class='fraction'>0/3</span>
            </div>
        
            
        </div>
        <p class="quiet">
            Press <em>n</em> or <em>j</em> to go to the next uncovered block, <em>b</em>, <em>p</em> or <em>k</em> for the previous block.
        </p>
    </div>
    <div class='status-line low'></div>
    <pre><table class="coverage">
<tr><td class="line-count quiet"><a name='L1'></a><a href='#L1'>1</a>
<a name='L2'></a><a href='#L2'>2</a>
<a name='L3'></a><a href='#L3'>3</a>
<a name='L4'></a><a href='#L4'>4</a>
<a name='L5'></a><a href='#L5'>5</a>
<a name='L6'></a><a href='#L6'>6</a>
<a name='L7'></a><a href='#L7'>7</a>
<a name='L8'></a><a href='#L8'>8</a>
<a name='L9'></a><a href='#L9'>9</a>
<a name='L10'></a><a href='#L10'>10</a>
<a name='L11'></a><a href='#L11'>11</a>
<a name='L12'></a><a href='#L12'>12</a>
<a name='L13'></a><a href='#L13'>13</a>
<a name='L14'></a><a href='#L14'>14</a>
<a name='L15'></a><a href='#L15'>15</a>
<a name='L16'></a><a href='#L16'>16</a>
<a name='L17'></a><a href='#L17'>17</a>
<a name='L18'></a><a href='#L18'>18</a>
<a name='L19'></a><a href='#L19'>19</a>
<a name='L20'></a><a href='#L20'>20</a>
<a name='L21'></a><a href='#L21'>21</a>
<a name='L22'></a><a href='#L22'>22</a>
<a name='L23'></a><a href='#L23'>23</a>
<a name='L24'></a><a href='#L24'>24</a>
<a name='L25'></a><a href='#L25'>25</a>
<a name='L26'></a><a href='#L26'>26</a>
<a name='L27'></a><a href='#L27'>27</a>
<a name='L28'></a><a href='#L28'>28</a>
<a name='L29'></a><a href='#L29'>29</a>
<a name='L30'></a><a href='#L30'>30</a>
<a name='L31'></a><a href='#L31'>31</a>
<a name='L32'></a><a href='#L32'>32</a>
<a name='L33'></a><a href='#L33'>33</a>
<a name='L34'></a><a href='#L34'>34</a>
<a name='L35'></a><a href='#L35'>35</a>
<a name='L36'></a><a href='#L36'>36</a>
<a name='L37'></a><a href='#L37'>37</a>
<a name='L38'></a><a href='#L38'>38</a>
<a name='L39'></a><a href='#L39'>39</a>
<a name='L40'></a><a href='#L40'>40</a>
<a name='L41'></a><a href='#L41'>41</a>
<a name='L42'></a><a href='#L42'>42</a>
<a name='L43'></a><a href='#L43'>43</a>
<a name='L44'></a><a href='#L44'>44</a>
<a name='L45'></a><a href='#L45'>45</a>
<a name='L46'></a><a href='#L46'>46</a>
<a name='L47'></a><a href='#L47'>47</a>
<a name='L48'></a><a href='#L48'>48</a>
<a name='L49'></a><a href='#L49'>49</a>
<a name='L50'></a><a href='#L50'>50</a>
<a name='L51'></a><a href='#L51'>51</a>
<a name='L52'></a><a href='#L52'>52</a>
<a name='L53'></a><a href='#L53'>53</a>
<a name='L54'></a><a href='#L54'>54</a>
<a name='L55'></a><a href='#L55'>55</a></td><td class="line-coverage quiet"><span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span></td><td class="text"><pre class="prettyprint lang-js">"use strict";
<span class="cstat-no" title="statement not covered" >(<span class="fstat-no" title="function not covered" >()</span>=&gt;{var Qe=<span class="cstat-no" title="statement not covered" >Object.create;</span>var ae=<span class="cstat-no" title="statement not covered" >Object.defineProperty;</span>var Pe=<span class="cstat-no" title="statement not covered" >Object.getOwnPropertyDescriptor;</span>var Ce=<span class="cstat-no" title="statement not covered" >Object.getOwnPropertyNames;</span>var Oe=<span class="cstat-no" title="statement not covered" >Object.getPrototypeOf,</span>Re=<span class="cstat-no" title="statement not covered" >Object.prototype.hasOwnProperty;</span>var _e=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;(<span class="cstat-no" title="statement not covered" >e||t((e={exports:{}}).exports,e),e.exports)</span>;</span></span>var Me=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e,n,r)=&gt;{<span class="cstat-no" title="statement not covered" >if(e&amp;&amp;typeof e=="object"||typeof e=="function")<span class="cstat-no" title="statement not covered" >for(let i of Ce(e))<span class="cstat-no" title="statement not covered" >!Re.call(t,i)&amp;&amp;i!==n&amp;&amp;ae(t,i,{get:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >e[i],</span>enumerable:!(r=Pe(e,i))||r.enumerable});<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn t}</span>;</span>var De=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e,n)=&gt;(<span class="cstat-no" title="statement not covered" >n=t!=null?Qe(Oe(t)):{},Me(e||!t||!t.__esModule?ae(n,"default",{value:t,enumerable:!0}):n,t))</span>;</span>var de=<span class="cstat-no" title="statement not covered" >_e(<span class="fstat-no" title="function not covered" >(c</span>e,he)=&gt;{<span class="cstat-no" title="statement not covered" >(<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(e){var n=<span class="cstat-no" title="statement not covered" >new t.Builder;<span class="cstat-no" title="statement not covered" ></span>return n.pipeline.add(t.trimmer,t.stopWordFilter,t.stemmer),n.searchPipeline.add(t.stemmer),e.call(n,n),n.build()}</span>;<span class="cstat-no" title="statement not covered" ></span>t.version="2.3.9";<span class="cstat-no" title="statement not covered" >t</span>.utils={},t.utils.warn=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >fu</span>nction(n){<span class="cstat-no" title="statement not covered" >e.console&amp;&amp;console.warn&amp;&amp;console.warn(n)}</span>}</span>(this),t.utils.asString=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return e==null?"":e.toString()}</span>,t.utils.clone=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >if(e==null)<span class="cstat-no" title="statement not covered" >return e;<span class="cstat-no" title="statement not covered" >f</span></span>or(var n=<span class="cstat-no" title="statement not covered" >Object.create(null),</span>r=<span class="cstat-no" title="statement not covered" >Object.keys(e),</span>i=<span class="cstat-no" title="statement not covered" >0;</span>i&lt;r.length;i++){var s=<span class="cstat-no" title="statement not covered" >r[i],</span>o=<span class="cstat-no" title="statement not covered" >e[s];<span class="cstat-no" title="statement not covered" ></span>if(Array.isArray(o)){<span class="cstat-no" title="statement not covered" >n[s]=o.slice();<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>i</span>f(typeof o=="string"||typeof o=="number"||typeof o=="boolean"){<span class="cstat-no" title="statement not covered" >n[s]=o;<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>t</span>hrow new TypeError("clone is not deep and does not support nested objects")}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn n}</span>,t.FieldRef=<span class="fstat-no" title="function not covered" >fu</span>nction(e,n,r){<span class="cstat-no" title="statement not covered" >this.docRef=e,this.fieldName=n,this._stringValue=r}</span>,t.FieldRef.joiner="/",t.FieldRef.fromString=<span class="fstat-no" title="function not covered" >fu</span>nction(e){var n=<span class="cstat-no" title="statement not covered" >e.indexOf(t.FieldRef.joiner);<span class="cstat-no" title="statement not covered" ></span>if(n===-1)<span class="cstat-no" title="statement not covered" >throw"malformed field ref string";v</span></span>ar r=<span class="cstat-no" title="statement not covered" >e.slice(0,n),</span>i=<span class="cstat-no" title="statement not covered" >e.slice(n+1);<span class="cstat-no" title="statement not covered" ></span>return new t.FieldRef(i,r,e)}</span>,t.FieldRef.prototype.toString=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this._stringValue==null&amp;&amp;(this._stringValue=this.fieldName+t.FieldRef.joiner+this.docRef),this._stringValue}</span>;<span class="cstat-no" title="statement not covered" >t</span>.Set=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >if(this.elements=Object.create(null),e){<span class="cstat-no" title="statement not covered" >this.length=e.length;<span class="cstat-no" title="statement not covered" >f</span>or(var n=<span class="cstat-no" title="statement not covered" >0;</span>n&lt;this.length;n++)<span class="cstat-no" title="statement not covered" >this.elements[e[n]]=!0}</span></span>else <span class="cstat-no" title="statement not covered" >this.length=0}</span></span>,t.Set.complete={intersect:<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return e}</span>,union:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this}</span>,contains:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return!0}</span>},t.Set.empty={intersect:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this}</span>,union:<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return e}</span>,contains:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return!1}</span>},t.Set.prototype.contains=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return!!this.elements[e]}</span>,t.Set.prototype.intersect=<span class="fstat-no" title="function not covered" >fu</span>nction(e){var n,r,i,s=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>if(e===t.Set.complete)<span class="cstat-no" title="statement not covered" >return this;<span class="cstat-no" title="statement not covered" >i</span></span>f(e===t.Set.empty)<span class="cstat-no" title="statement not covered" >return e;<span class="cstat-no" title="statement not covered" >t</span></span>his.length&lt;e.length?(n=this,r=e):(n=e,r=this),i=Object.keys(n.elements);<span class="cstat-no" title="statement not covered" >f</span>or(var o=<span class="cstat-no" title="statement not covered" >0;</span>o&lt;i.length;o++){var a=<span class="cstat-no" title="statement not covered" >i[o];<span class="cstat-no" title="statement not covered" ></span>a in r.elements&amp;&amp;s.push(a)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn new t.Set(s)}</span>,t.Set.prototype.union=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return e===t.Set.complete?t.Set.complete:e===t.Set.empty?this:new t.Set(Object.keys(this.elements).concat(Object.keys(e.elements)))}</span>,t.idf=<span class="fstat-no" title="function not covered" >fu</span>nction(e,n){var r=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(var i in e)<span class="cstat-no" title="statement not covered" >i!="_index"&amp;&amp;(r+=Object.keys(e[i]).length);v</span></span>ar s=<span class="cstat-no" title="statement not covered" >(n-r+.5)/(r+.5);<span class="cstat-no" title="statement not covered" ></span>return Math.log(1+Math.abs(s))}</span>,t.Token=<span class="fstat-no" title="function not covered" >fu</span>nction(e,n){<span class="cstat-no" title="statement not covered" >this.str=e||"",this.metadata=n||{}}</span>,t.Token.prototype.toString=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.str}</span>,t.Token.prototype.update=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return this.str=e(this.str,this.metadata),this}</span>,t.Token.prototype.clone=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return e=e||<span class="fstat-no" title="function not covered" >fu</span>nction(n){<span class="cstat-no" title="statement not covered" >return n}</span>,new t.Token(e(this.str,this.metadata),this.metadata)}</span>;<span class="cstat-no" title="statement not covered" >t</span>.tokenizer=<span class="fstat-no" title="function not covered" >fu</span>nction(e,n){<span class="cstat-no" title="statement not covered" >if(e==null||e==null)<span class="cstat-no" title="statement not covered" >return[];<span class="cstat-no" title="statement not covered" >i</span></span>f(Array.isArray(e))<span class="cstat-no" title="statement not covered" >return e.map(<span class="fstat-no" title="function not covered" >fu</span>nction(m){<span class="cstat-no" title="statement not covered" >return new t.Token(t.utils.asString(m).toLowerCase(),t.utils.clone(n))}</span>);<span class="cstat-no" title="statement not covered" >f</span></span>or(var r=<span class="cstat-no" title="statement not covered" >e.toString().toLowerCase(),</span>i=<span class="cstat-no" title="statement not covered" >r.length,</span>s=<span class="cstat-no" title="statement not covered" >[],</span>o=<span class="cstat-no" title="statement not covered" >0,</span>a=<span class="cstat-no" title="statement not covered" >0;</span>o&lt;=i;o++){var u=<span class="cstat-no" title="statement not covered" >r.charAt(o),</span>l=<span class="cstat-no" title="statement not covered" >o-a;<span class="cstat-no" title="statement not covered" ></span>if(u.match(t.tokenizer.separator)||o==i){<span class="cstat-no" title="statement not covered" >if(l&gt;0){var h=<span class="cstat-no" title="statement not covered" >t.utils.clone(n)||{};<span class="cstat-no" title="statement not covered" ></span>h.position=[a,l],h.index=s.length,s.push(new t.Token(r.slice(a,o),h))}<span class="cstat-no" title="statement not covered" ></span>a</span>=o+1}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn s}</span>,t.tokenizer.separator=/[\s\-]+/;<span class="cstat-no" title="statement not covered" >t</span>.Pipeline=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >this._stack=[]}</span>,t.Pipeline.registeredFunctions=Object.create(null),t.Pipeline.registerFunction=<span class="fstat-no" title="function not covered" >fu</span>nction(e,n){<span class="cstat-no" title="statement not covered" >n in this.registeredFunctions&amp;&amp;t.utils.warn("Overwriting existing registered function: "+n),e.label=n,t.Pipeline.registeredFunctions[e.label]=e}</span>,t.Pipeline.warnIfFunctionNotRegistered=<span class="fstat-no" title="function not covered" >fu</span>nction(e){var n=<span class="cstat-no" title="statement not covered" >e.label&amp;&amp;e.label in this.registeredFunctions;<span class="cstat-no" title="statement not covered" ></span>n||t.utils.warn(`Function is not registered with pipeline. This may cause problems when serialising the index.</span></span></span></span></span>
`,e)},t.Pipeline.load=<span class="fstat-no" title="function not covered" >fu</span>nction(e){var n=<span class="cstat-no" title="statement not covered" >new t.Pipeline;<span class="cstat-no" title="statement not covered" ></span>return e.forEach(<span class="fstat-no" title="function not covered" >fu</span>nction(r){var i=<span class="cstat-no" title="statement not covered" >t.Pipeline.registeredFunctions[r];<span class="cstat-no" title="statement not covered" ></span>if(i)<span class="cstat-no" title="statement not covered" >n.add(i);e</span>lse <span class="cstat-no" title="statement not covered" >throw new Error("Cannot load unregistered function: "+r)}</span></span>),n}</span>,t.Pipeline.prototype.add=<span class="fstat-no" title="function not covered" >fu</span>nction(){var e=<span class="cstat-no" title="statement not covered" >Array.prototype.slice.call(arguments);<span class="cstat-no" title="statement not covered" ></span>e.forEach(<span class="fstat-no" title="function not covered" >fu</span>nction(n){<span class="cstat-no" title="statement not covered" >t.Pipeline.warnIfFunctionNotRegistered(n),this._stack.push(n)}</span>,this)}</span>,t.Pipeline.prototype.after=<span class="fstat-no" title="function not covered" >fu</span>nction(e,n){<span class="cstat-no" title="statement not covered" >t.Pipeline.warnIfFunctionNotRegistered(n);v</span>ar r=<span class="cstat-no" title="statement not covered" >this._stack.indexOf(e);<span class="cstat-no" title="statement not covered" ></span>if(r==-1)<span class="cstat-no" title="statement not covered" >throw new Error("Cannot find existingFn");<span class="cstat-no" title="statement not covered" >r</span></span>=r+1,this._stack.splice(r,0,n)}</span>,t.Pipeline.prototype.before=<span class="fstat-no" title="function not covered" >fu</span>nction(e,n){<span class="cstat-no" title="statement not covered" >t.Pipeline.warnIfFunctionNotRegistered(n);v</span>ar r=<span class="cstat-no" title="statement not covered" >this._stack.indexOf(e);<span class="cstat-no" title="statement not covered" ></span>if(r==-1)<span class="cstat-no" title="statement not covered" >throw new Error("Cannot find existingFn");<span class="cstat-no" title="statement not covered" >t</span></span>his._stack.splice(r,0,n)}</span>,t.Pipeline.prototype.remove=<span class="fstat-no" title="function not covered" >fu</span>nction(e){var n=<span class="cstat-no" title="statement not covered" >this._stack.indexOf(e);<span class="cstat-no" title="statement not covered" ></span>n!=-1&amp;&amp;this._stack.splice(n,1)}</span>,t.Pipeline.prototype.run=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >for(var n=<span class="cstat-no" title="statement not covered" >this._stack.length,</span>r=<span class="cstat-no" title="statement not covered" >0;</span>r&lt;n;r++){<span class="cstat-no" title="statement not covered" >for(var i=<span class="cstat-no" title="statement not covered" >this._stack[r],</span>s=<span class="cstat-no" title="statement not covered" >[],</span>o=<span class="cstat-no" title="statement not covered" >0;</span>o&lt;e.length;o++){var a=<span class="cstat-no" title="statement not covered" >i(e[o],o,e);<span class="cstat-no" title="statement not covered" ></span>if(!(a==null||a===""))<span class="cstat-no" title="statement not covered" >if(Array.isArray(a))<span class="cstat-no" title="statement not covered" >for(var u=<span class="cstat-no" title="statement not covered" >0;</span>u&lt;a.length;u++)<span class="cstat-no" title="statement not covered" >s.push(a[u]);e</span></span>lse <span class="cstat-no" title="statement not covered" >s.push(a)}<span class="cstat-no" title="statement not covered" ></span></span></span>e</span>=s}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn e}</span>,t.Pipeline.prototype.runString=<span class="fstat-no" title="function not covered" >fu</span>nction(e,n){var r=<span class="cstat-no" title="statement not covered" >new t.Token(e,n);<span class="cstat-no" title="statement not covered" ></span>return this.run([r]).map(<span class="fstat-no" title="function not covered" >fu</span>nction(i){<span class="cstat-no" title="statement not covered" >return i.toString()}</span>)}</span>,t.Pipeline.prototype.reset=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >this._stack=[]}</span>,t.Pipeline.prototype.toJSON=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this._stack.map(<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return t.Pipeline.warnIfFunctionNotRegistered(e),e.label}</span>)}</span>;<span class="cstat-no" title="statement not covered" >t.Vector=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >this._magnitude=0,this.elements=e||[]}</span>,t.Vector.prototype.positionForIndex=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >if(this.elements.length==0)<span class="cstat-no" title="statement not covered" >return 0;<span class="cstat-no" title="statement not covered" >f</span></span>or(var n=<span class="cstat-no" title="statement not covered" >0,</span>r=<span class="cstat-no" title="statement not covered" >this.elements.length/2,</span>i=<span class="cstat-no" title="statement not covered" >r-n,</span>s=<span class="cstat-no" title="statement not covered" >Math.floor(i/2),</span>o=<span class="cstat-no" title="statement not covered" >this.elements[s*2];</span>i&gt;1&amp;&amp;(o&lt;e&amp;&amp;(n=s),o&gt;e&amp;&amp;(r=s),o!=e);)<span class="cstat-no" title="statement not covered" >i=r-n,s=n+Math.floor(i/2),o=this.elements[s*2];<span class="cstat-no" title="statement not covered" >i</span></span>f(o==e||o&gt;e)<span class="cstat-no" title="statement not covered" >return s*2;<span class="cstat-no" title="statement not covered" >i</span></span>f(o&lt;e)<span class="cstat-no" title="statement not covered" >return(s+1)*2}</span></span>,t.Vector.prototype.insert=<span class="fstat-no" title="function not covered" >fu</span>nction(e,n){<span class="cstat-no" title="statement not covered" >this.upsert(e,n,<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >throw"duplicate index"}</span>)}</span>,t.Vector.prototype.upsert=<span class="fstat-no" title="function not covered" >fu</span>nction(e,n,r){<span class="cstat-no" title="statement not covered" >this._magnitude=0;v</span>ar i=<span class="cstat-no" title="statement not covered" >this.positionForIndex(e);<span class="cstat-no" title="statement not covered" ></span>this.elements[i]==e?this.elements[i+1]=r(this.elements[i+1],n):this.elements.splice(i,0,e,n)}</span>,t.Vector.prototype.magnitude=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >if(this._magnitude)<span class="cstat-no" title="statement not covered" >return this._magnitude;<span class="cstat-no" title="statement not covered" >f</span></span>or(var e=<span class="cstat-no" title="statement not covered" >0,</span>n=<span class="cstat-no" title="statement not covered" >this.elements.length,</span>r=<span class="cstat-no" title="statement not covered" >1;</span>r&lt;n;r+=2){var i=<span class="cstat-no" title="statement not covered" >this.elements[r];<span class="cstat-no" title="statement not covered" ></span>e+=i*i}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn this._magnitude=Math.sqrt(e)}</span>,t.Vector.prototype.dot=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >for(var n=<span class="cstat-no" title="statement not covered" >0,</span>r=<span class="cstat-no" title="statement not covered" >this.elements,</span>i=<span class="cstat-no" title="statement not covered" >e.elements,</span>s=<span class="cstat-no" title="statement not covered" >r.length,</span>o=<span class="cstat-no" title="statement not covered" >i.length,</span>a=<span class="cstat-no" title="statement not covered" >0,</span>u=<span class="cstat-no" title="statement not covered" >0,</span>l=<span class="cstat-no" title="statement not covered" >0,</span>h=<span class="cstat-no" title="statement not covered" >0;</span>l&lt;s&amp;&amp;h&lt;o;)<span class="cstat-no" title="statement not covered" >a=r[l],u=i[h],a&lt;u?l+=2:a&gt;u?h+=2:a==u&amp;&amp;(n+=r[l+1]*i[h+1],l+=2,h+=2);<span class="cstat-no" title="statement not covered" >r</span></span>eturn n}</span>,t.Vector.prototype.similarity=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return this.dot(e)/this.magnitude()||0}</span>,t.Vector.prototype.toArray=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >for(var e=<span class="cstat-no" title="statement not covered" >new Array(this.elements.length/2),</span>n=<span class="cstat-no" title="statement not covered" >1,</span>r=<span class="cstat-no" title="statement not covered" >0;</span>n&lt;this.elements.length;n+=2,r++)<span class="cstat-no" title="statement not covered" >e[r]=this.elements[n];<span class="cstat-no" title="statement not covered" >r</span></span>eturn e}</span>,t.Vector.prototype.toJSON=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.elements}</span>;<span class="cstat-no" title="statement not covered" >t</span>.stemmer=<span class="fstat-no" title="function not covered" >fu</span>nction(){var e=<span class="cstat-no" title="statement not covered" >{ational:"ate",tional:"tion",enci:"ence",anci:"ance",izer:"ize",bli:"ble",alli:"al",entli:"ent",eli:"e",ousli:"ous",ization:"ize",ation:"ate",ator:"ate",alism:"al",iveness:"ive",fulness:"ful",ousness:"ous",aliti:"al",iviti:"ive",biliti:"ble",logi:"log"},</span>n=<span class="cstat-no" title="statement not covered" >{icate:"ic",ative:"",alize:"al",iciti:"ic",ical:"ic",ful:"",ness:""},</span>r=<span class="cstat-no" title="statement not covered" >"[^aeiou]",</span>i=<span class="cstat-no" title="statement not covered" >"[aeiouy]",</span>s=<span class="cstat-no" title="statement not covered" >r+"[^aeiouy]*",</span>o=<span class="cstat-no" title="statement not covered" >i+"[aeiou]*",</span>a=<span class="cstat-no" title="statement not covered" >"^("+s+")?"+o+s,</span>u=<span class="cstat-no" title="statement not covered" >"^("+s+")?"+o+s+"("+o+")?$",</span>l=<span class="cstat-no" title="statement not covered" >"^("+s+")?"+o+s+o+s,</span>h=<span class="cstat-no" title="statement not covered" >"^("+s+")?"+i,</span>m=<span class="cstat-no" title="statement not covered" >new RegExp(a),</span>v=<span class="cstat-no" title="statement not covered" >new RegExp(l),</span>b=<span class="cstat-no" title="statement not covered" >new RegExp(u),</span>y=<span class="cstat-no" title="statement not covered" >new RegExp(h),</span>E=<span class="cstat-no" title="statement not covered" >/^(.+?)(ss|i)es$/,</span>f=<span class="cstat-no" title="statement not covered" >/^(.+?)([^s])s$/,</span>p=<span class="cstat-no" title="statement not covered" >/^(.+?)eed$/,</span>w=<span class="cstat-no" title="statement not covered" >/^(.+?)(ed|ing)$/,</span>S=<span class="cstat-no" title="statement not covered" >/.$/,</span>I=<span class="cstat-no" title="statement not covered" >/(at|bl|iz)$/,</span>_=<span class="cstat-no" title="statement not covered" >new RegExp("([^aeiouylsz])\\1$"),</span>z=<span class="cstat-no" title="statement not covered" >new RegExp("^"+s+i+"[^aeiouwxy]$"),</span>A=<span class="cstat-no" title="statement not covered" >/^(.+?[^aeiou])y$/,</span>q=<span class="cstat-no" title="statement not covered" >/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/,</span>$=<span class="cstat-no" title="statement not covered" >/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/,</span>V=<span class="cstat-no" title="statement not covered" >/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/,</span>W=<span class="cstat-no" title="statement not covered" >/^(.+?)(s|t)(ion)$/,</span>P=<span class="cstat-no" title="statement not covered" >/^(.+?)e$/,</span>U=<span class="cstat-no" title="statement not covered" >/ll$/,</span>G=<span class="cstat-no" title="statement not covered" >new RegExp("^"+s+i+"[^aeiouwxy]$"),</span>N=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(c){var g,C,T,d,x,O,D;<span class="cstat-no" title="statement not covered" >if(c.length&lt;3)<span class="cstat-no" title="statement not covered" >return c;<span class="cstat-no" title="statement not covered" >i</span></span>f(T=c.substr(0,1),T=="y"&amp;&amp;(c=T.toUpperCase()+c.substr(1)),d=E,x=f,d.test(c)?c=c.replace(d,"$1$2"):x.test(c)&amp;&amp;(c=c.replace(x,"$1$2")),d=p,x=w,d.test(c)){var L=<span class="cstat-no" title="statement not covered" >d.exec(c);<span class="cstat-no" title="statement not covered" ></span>d=m,d.test(L[1])&amp;&amp;(d=S,c=c.replace(d,""))}</span>else <span class="cstat-no" title="statement not covered" >if(x.test(c)){var L=<span class="cstat-no" title="statement not covered" >x.exec(c);<span class="cstat-no" title="statement not covered" ></span>g=L[1],x=y,x.test(g)&amp;&amp;(c=g,x=I,O=_,D=z,x.test(c)?c=c+"e":O.test(c)?(d=S,c=c.replace(d,"")):D.test(c)&amp;&amp;(c=c+"e"))}<span class="cstat-no" title="statement not covered" ></span>i</span></span>f(d=A,d.test(c)){var L=<span class="cstat-no" title="statement not covered" >d.exec(c);<span class="cstat-no" title="statement not covered" ></span>g=L[1],c=g+"i"}<span class="cstat-no" title="statement not covered" ></span>i</span>f(d=q,d.test(c)){var L=<span class="cstat-no" title="statement not covered" >d.exec(c);<span class="cstat-no" title="statement not covered" ></span>g=L[1],C=L[2],d=m,d.test(g)&amp;&amp;(c=g+e[C])}<span class="cstat-no" title="statement not covered" ></span>i</span>f(d=$,d.test(c)){var L=<span class="cstat-no" title="statement not covered" >d.exec(c);<span class="cstat-no" title="statement not covered" ></span>g=L[1],C=L[2],d=m,d.test(g)&amp;&amp;(c=g+n[C])}<span class="cstat-no" title="statement not covered" ></span>i</span>f(d=V,x=W,d.test(c)){var L=<span class="cstat-no" title="statement not covered" >d.exec(c);<span class="cstat-no" title="statement not covered" ></span>g=L[1],d=v,d.test(g)&amp;&amp;(c=g)}</span>else <span class="cstat-no" title="statement not covered" >if(x.test(c)){var L=<span class="cstat-no" title="statement not covered" >x.exec(c);<span class="cstat-no" title="statement not covered" ></span>g=L[1]+L[2],x=v,x.test(g)&amp;&amp;(c=g)}<span class="cstat-no" title="statement not covered" ></span>i</span></span>f(d=P,d.test(c)){var L=<span class="cstat-no" title="statement not covered" >d.exec(c);<span class="cstat-no" title="statement not covered" ></span>g=L[1],d=v,x=b,O=G,(d.test(g)||x.test(g)&amp;&amp;!O.test(g))&amp;&amp;(c=g)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn d=U,x=v,d.test(c)&amp;&amp;x.test(c)&amp;&amp;(d=S,c=c.replace(d,"")),T=="y"&amp;&amp;(c=T.toLowerCase()+c.substr(1)),c}</span>;<span class="cstat-no" title="statement not covered" ></span>return <span class="fstat-no" title="function not covered" >fu</span>nction(M){<span class="cstat-no" title="statement not covered" >return M.update(N)}</span>}</span>(),t.Pipeline.registerFunction(t.stemmer,"stemmer");<span class="cstat-no" title="statement not covered" >t</span>.generateStopWordFilter=<span class="fstat-no" title="function not covered" >fu</span>nction(e){var n=<span class="cstat-no" title="statement not covered" >e.reduce(<span class="fstat-no" title="function not covered" >fu</span>nction(r,i){<span class="cstat-no" title="statement not covered" >return r[i]=i,r}</span>,{});<span class="cstat-no" title="statement not covered" ></span>return <span class="fstat-no" title="function not covered" >fu</span>nction(r){<span class="cstat-no" title="statement not covered" >if(r&amp;&amp;n[r.toString()]!==r.toString())<span class="cstat-no" title="statement not covered" >return r}</span></span>}</span>,t.stopWordFilter=t.generateStopWordFilter(["a","able","about","across","after","all","almost","also","am","among","an","and","any","are","as","at","be","because","been","but","by","can","cannot","could","dear","did","do","does","either","else","ever","every","for","from","get","got","had","has","have","he","her","hers","him","his","how","however","i","if","in","into","is","it","its","just","least","let","like","likely","may","me","might","most","must","my","neither","no","nor","not","of","off","often","on","only","or","other","our","own","rather","said","say","says","she","should","since","so","some","than","that","the","their","them","then","there","these","they","this","tis","to","too","twas","us","wants","was","we","were","what","when","where","which","while","who","whom","why","will","with","would","yet","you","your"]),t.Pipeline.registerFunction(t.stopWordFilter,"stopWordFilter");<span class="cstat-no" title="statement not covered" >t</span>.trimmer=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return e.update(<span class="fstat-no" title="function not covered" >fu</span>nction(n){<span class="cstat-no" title="statement not covered" >return n.replace(/^\W+/,"").replace(/\W+$/,"")}</span>)}</span>,t.Pipeline.registerFunction(t.trimmer,"trimmer");<span class="cstat-no" title="statement not covered" >t</span>.TokenSet=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >this.final=!1,this.edges={},this.id=t.TokenSet._nextId,t.TokenSet._nextId+=1}</span>,t.TokenSet._nextId=1,t.TokenSet.fromArray=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >for(var n=<span class="cstat-no" title="statement not covered" >new t.TokenSet.Builder,</span>r=<span class="cstat-no" title="statement not covered" >0,</span>i=<span class="cstat-no" title="statement not covered" >e.length;</span>r&lt;i;r++)<span class="cstat-no" title="statement not covered" >n.insert(e[r]);<span class="cstat-no" title="statement not covered" >r</span></span>eturn n.finish(),n.root}</span>,t.TokenSet.fromClause=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return"editDistance"in e?t.TokenSet.fromFuzzyString(e.term,e.editDistance):t.TokenSet.fromString(e.term)}</span>,t.TokenSet.fromFuzzyString=<span class="fstat-no" title="function not covered" >fu</span>nction(e,n){<span class="cstat-no" title="statement not covered" >for(var r=<span class="cstat-no" title="statement not covered" >new t.TokenSet,</span>i=<span class="cstat-no" title="statement not covered" >[{node:r,editsRemaining:n,str:e}];</span>i.length;){var s=<span class="cstat-no" title="statement not covered" >i.pop();<span class="cstat-no" title="statement not covered" ></span>if(s.str.length&gt;0){var o=<span class="cstat-no" title="statement not covered" >s.str.charAt(0),</span>a;<span class="cstat-no" title="statement not covered" >o in s.node.edges?a=s.node.edges[o]:(a=new t.TokenSet,s.node.edges[o]=a),s.str.length==1&amp;&amp;(a.final=!0),i.push({node:a,editsRemaining:s.editsRemaining,str:s.str.slice(1)})}<span class="cstat-no" title="statement not covered" ></span>i</span>f(s.editsRemaining!=0){<span class="cstat-no" title="statement not covered" >if("*"in s.node.edges)var u=<span class="cstat-no" title="statement not covered" >s.node.edges["*"];</span>else{var u=<span class="cstat-no" title="statement not covered" >new t.TokenSet;<span class="cstat-no" title="statement not covered" ></span>s.node.edges["*"]=u}<span class="cstat-no" title="statement not covered" ></span>i</span>f(s.str.length==0&amp;&amp;(u.final=!0),i.push({node:u,editsRemaining:s.editsRemaining-1,str:s.str}),s.str.length&gt;1&amp;&amp;i.push({node:s.node,editsRemaining:s.editsRemaining-1,str:s.str.slice(1)}),s.str.length==1&amp;&amp;(s.node.final=!0),s.str.length&gt;=1){<span class="cstat-no" title="statement not covered" >if("*"in s.node.edges)var l=<span class="cstat-no" title="statement not covered" >s.node.edges["*"];</span>else{var l=<span class="cstat-no" title="statement not covered" >new t.TokenSet;<span class="cstat-no" title="statement not covered" ></span>s.node.edges["*"]=l}<span class="cstat-no" title="statement not covered" ></span>s</span>.str.length==1&amp;&amp;(l.final=!0),i.push({node:l,editsRemaining:s.editsRemaining-1,str:s.str.slice(1)})}<span class="cstat-no" title="statement not covered" ></span>i</span>f(s.str.length&gt;1){var h=<span class="cstat-no" title="statement not covered" >s.str.charAt(0),</span>m=<span class="cstat-no" title="statement not covered" >s.str.charAt(1),</span>v;<span class="cstat-no" title="statement not covered" >m in s.node.edges?v=s.node.edges[m]:(v=new t.TokenSet,s.node.edges[m]=v),s.str.length==1&amp;&amp;(v.final=!0),i.push({node:v,editsRemaining:s.editsRemaining-1,str:h+s.str.slice(2)})}</span>}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn r}</span>,t.TokenSet.fromString=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >for(var n=<span class="cstat-no" title="statement not covered" >new t.TokenSet,</span>r=<span class="cstat-no" title="statement not covered" >n,</span>i=<span class="cstat-no" title="statement not covered" >0,</span>s=<span class="cstat-no" title="statement not covered" >e.length;</span>i&lt;s;i++){var o=<span class="cstat-no" title="statement not covered" >e[i],</span>a=<span class="cstat-no" title="statement not covered" >i==s-1;<span class="cstat-no" title="statement not covered" ></span>if(o=="*")<span class="cstat-no" title="statement not covered" >n.edges[o]=n,n.final=a;e</span>lse{var u=<span class="cstat-no" title="statement not covered" >new t.TokenSet;<span class="cstat-no" title="statement not covered" ></span>u.final=a,n.edges[o]=u,n=u}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn r}</span>,t.TokenSet.prototype.toArray=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >for(var e=<span class="cstat-no" title="statement not covered" >[],</span>n=<span class="cstat-no" title="statement not covered" >[{prefix:"",node:this}];</span>n.length;){var r=<span class="cstat-no" title="statement not covered" >n.pop(),</span>i=<span class="cstat-no" title="statement not covered" >Object.keys(r.node.edges),</span>s=<span class="cstat-no" title="statement not covered" >i.length;<span class="cstat-no" title="statement not covered" ></span>r.node.final&amp;&amp;(r.prefix.charAt(0),e.push(r.prefix));<span class="cstat-no" title="statement not covered" >f</span>or(var o=<span class="cstat-no" title="statement not covered" >0;</span>o&lt;s;o++){var a=<span class="cstat-no" title="statement not covered" >i[o];<span class="cstat-no" title="statement not covered" ></span>n.push({prefix:r.prefix.concat(a),node:r.node.edges[a]})}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn e}</span>,t.TokenSet.prototype.toString=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >if(this._str)<span class="cstat-no" title="statement not covered" >return this._str;<span class="cstat-no" title="statement not covered" >f</span></span>or(var e=<span class="cstat-no" title="statement not covered" >this.final?"1":"0",</span>n=<span class="cstat-no" title="statement not covered" >Object.keys(this.edges).sort(),</span>r=<span class="cstat-no" title="statement not covered" >n.length,</span>i=<span class="cstat-no" title="statement not covered" >0;</span>i&lt;r;i++){var s=<span class="cstat-no" title="statement not covered" >n[i],</span>o=<span class="cstat-no" title="statement not covered" >this.edges[s];<span class="cstat-no" title="statement not covered" ></span>e=e+s+o.id}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn e}</span>,t.TokenSet.prototype.intersect=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >for(var n=<span class="cstat-no" title="statement not covered" >new t.TokenSet,</span>r=<span class="cstat-no" title="statement not covered" >void 0,</span>i=<span class="cstat-no" title="statement not covered" >[{qNode:e,output:n,node:this}];</span>i.length;){<span class="cstat-no" title="statement not covered" >r=i.pop();<span class="cstat-no" title="statement not covered" >f</span>or(var s=<span class="cstat-no" title="statement not covered" >Object.keys(r.qNode.edges),</span>o=<span class="cstat-no" title="statement not covered" >s.length,</span>a=<span class="cstat-no" title="statement not covered" >Object.keys(r.node.edges),</span>u=<span class="cstat-no" title="statement not covered" >a.length,</span>l=<span class="cstat-no" title="statement not covered" >0;</span>l&lt;o;l++)<span class="cstat-no" title="statement not covered" >for(var h=<span class="cstat-no" title="statement not covered" >s[l],</span>m=<span class="cstat-no" title="statement not covered" >0;</span>m&lt;u;m++){var v=<span class="cstat-no" title="statement not covered" >a[m];<span class="cstat-no" title="statement not covered" ></span>if(v==h||h=="*"){var b=<span class="cstat-no" title="statement not covered" >r.node.edges[v],</span>y=<span class="cstat-no" title="statement not covered" >r.qNode.edges[h],</span>E=<span class="cstat-no" title="statement not covered" >b.final&amp;&amp;y.final,</span>f=<span class="cstat-no" title="statement not covered" >void 0;<span class="cstat-no" title="statement not covered" ></span>v in r.output.edges?(f=r.output.edges[v],f.final=f.final||E):(f=new t.TokenSet,f.final=E,r.output.edges[v]=f),i.push({qNode:y,output:f,node:b})}</span>}</span>}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn n}</span>,t.TokenSet.Builder=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >this.previousWord="",this.root=new t.TokenSet,this.uncheckedNodes=[],this.minimizedNodes={}}</span>,t.TokenSet.Builder.prototype.insert=<span class="fstat-no" title="function not covered" >fu</span>nction(e){var n,r=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>if(e&lt;this.previousWord)<span class="cstat-no" title="statement not covered" >throw new Error("Out of order word insertion");<span class="cstat-no" title="statement not covered" >f</span></span>or(var i=<span class="cstat-no" title="statement not covered" >0;</span>i&lt;e.length&amp;&amp;i&lt;this.previousWord.length&amp;&amp;e[i]==this.previousWord[i];i++)<span class="cstat-no" title="statement not covered" >r++;<span class="cstat-no" title="statement not covered" >t</span></span>his.minimize(r),this.uncheckedNodes.length==0?n=this.root:n=this.uncheckedNodes[this.uncheckedNodes.length-1].child;<span class="cstat-no" title="statement not covered" >f</span>or(var i=<span class="cstat-no" title="statement not covered" >r;</span>i&lt;e.length;i++){var s=<span class="cstat-no" title="statement not covered" >new t.TokenSet,</span>o=<span class="cstat-no" title="statement not covered" >e[i];<span class="cstat-no" title="statement not covered" ></span>n.edges[o]=s,this.uncheckedNodes.push({parent:n,char:o,child:s}),n=s}<span class="cstat-no" title="statement not covered" ></span>n</span>.final=!0,this.previousWord=e}</span>,t.TokenSet.Builder.prototype.finish=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >this.minimize(0)}</span>,t.TokenSet.Builder.prototype.minimize=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >for(var n=<span class="cstat-no" title="statement not covered" >this.uncheckedNodes.length-1;</span>n&gt;=e;n--){var r=<span class="cstat-no" title="statement not covered" >this.uncheckedNodes[n],</span>i=<span class="cstat-no" title="statement not covered" >r.child.toString();<span class="cstat-no" title="statement not covered" ></span>i in this.minimizedNodes?r.parent.edges[r.char]=this.minimizedNodes[i]:(r.child._str=i,this.minimizedNodes[i]=r.child),this.uncheckedNodes.pop()}</span>}</span>;<span class="cstat-no" title="statement not covered" >t</span>.Index=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >this.invertedIndex=e.invertedIndex,this.fieldVectors=e.fieldVectors,this.tokenSet=e.tokenSet,this.fields=e.fields,this.pipeline=e.pipeline}</span>,t.Index.prototype.search=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return this.query(<span class="fstat-no" title="function not covered" >fu</span>nction(n){var r=<span class="cstat-no" title="statement not covered" >new t.QueryParser(e,n);<span class="cstat-no" title="statement not covered" ></span>r.parse()}</span>)}</span>,t.Index.prototype.query=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >for(var n=<span class="cstat-no" title="statement not covered" >new t.Query(this.fields),</span>r=<span class="cstat-no" title="statement not covered" >Object.create(null),</span>i=<span class="cstat-no" title="statement not covered" >Object.create(null),</span>s=<span class="cstat-no" title="statement not covered" >Object.create(null),</span>o=<span class="cstat-no" title="statement not covered" >Object.create(null),</span>a=<span class="cstat-no" title="statement not covered" >Object.create(null),</span>u=<span class="cstat-no" title="statement not covered" >0;</span>u&lt;this.fields.length;u++)<span class="cstat-no" title="statement not covered" >i[this.fields[u]]=new t.Vector;<span class="cstat-no" title="statement not covered" >e</span></span>.call(n,n);<span class="cstat-no" title="statement not covered" >f</span>or(var u=<span class="cstat-no" title="statement not covered" >0;</span>u&lt;n.clauses.length;u++){var l=<span class="cstat-no" title="statement not covered" >n.clauses[u],</span>h=<span class="cstat-no" title="statement not covered" >null,</span>m=<span class="cstat-no" title="statement not covered" >t.Set.empty;<span class="cstat-no" title="statement not covered" ></span>l.usePipeline?h=this.pipeline.runString(l.term,{fields:l.fields}):h=[l.term];<span class="cstat-no" title="statement not covered" >f</span>or(var v=<span class="cstat-no" title="statement not covered" >0;</span>v&lt;h.length;v++){var b=<span class="cstat-no" title="statement not covered" >h[v];<span class="cstat-no" title="statement not covered" ></span>l.term=b;v</span>ar y=<span class="cstat-no" title="statement not covered" >t.TokenSet.fromClause(l),</span>E=<span class="cstat-no" title="statement not covered" >this.tokenSet.intersect(y).toArray();<span class="cstat-no" title="statement not covered" ></span>if(E.length===0&amp;&amp;l.presence===t.Query.presence.REQUIRED){<span class="cstat-no" title="statement not covered" >for(var f=<span class="cstat-no" title="statement not covered" >0;</span>f&lt;l.fields.length;f++){var p=<span class="cstat-no" title="statement not covered" >l.fields[f];<span class="cstat-no" title="statement not covered" ></span>o[p]=t.Set.empty}<span class="cstat-no" title="statement not covered" ></span>b</span>reak}<span class="cstat-no" title="statement not covered" ></span>f</span>or(var w=<span class="cstat-no" title="statement not covered" >0;</span>w&lt;E.length;w++)<span class="cstat-no" title="statement not covered" >for(var S=<span class="cstat-no" title="statement not covered" >E[w],</span>I=<span class="cstat-no" title="statement not covered" >this.invertedIndex[S],</span>_=<span class="cstat-no" title="statement not covered" >I._index,</span>f=<span class="cstat-no" title="statement not covered" >0;</span>f&lt;l.fields.length;f++){var p=<span class="cstat-no" title="statement not covered" >l.fields[f],</span>z=<span class="cstat-no" title="statement not covered" >I[p],</span>A=<span class="cstat-no" title="statement not covered" >Object.keys(z),</span>q=<span class="cstat-no" title="statement not covered" >S+"/"+p,</span>$=<span class="cstat-no" title="statement not covered" >new t.Set(A);<span class="cstat-no" title="statement not covered" ></span>if(l.presence==t.Query.presence.REQUIRED&amp;&amp;(m=m.union($),o[p]===void 0&amp;&amp;(o[p]=t.Set.complete)),l.presence==t.Query.presence.PROHIBITED){<span class="cstat-no" title="statement not covered" >a[p]===void 0&amp;&amp;(a[p]=t.Set.empty),a[p]=a[p].union($);<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>i</span>f(i[p].upsert(_,l.boost,<span class="fstat-no" title="function not covered" >fu</span>nction(ke,Ie){<span class="cstat-no" title="statement not covered" >return ke+Ie}</span>),!s[q]){<span class="cstat-no" title="statement not covered" >for(var V=<span class="cstat-no" title="statement not covered" >0;</span>V&lt;A.length;V++){var W=<span class="cstat-no" title="statement not covered" >A[V],</span>P=<span class="cstat-no" title="statement not covered" >new t.FieldRef(W,p),</span>U=<span class="cstat-no" title="statement not covered" >z[W],</span>G;<span class="cstat-no" title="statement not covered" >(G=r[P])===void 0?r[P]=new t.MatchData(S,p,U):G.add(S,p,U)}<span class="cstat-no" title="statement not covered" ></span>s</span>[q]=!0}</span>}</span>}<span class="cstat-no" title="statement not covered" ></span></span>i</span>f(l.presence===t.Query.presence.REQUIRED)<span class="cstat-no" title="statement not covered" >for(var f=<span class="cstat-no" title="statement not covered" >0;</span>f&lt;l.fields.length;f++){var p=<span class="cstat-no" title="statement not covered" >l.fields[f];<span class="cstat-no" title="statement not covered" ></span>o[p]=o[p].intersect(m)}</span>}<span class="cstat-no" title="statement not covered" ></span></span>f</span>or(var N=<span class="cstat-no" title="statement not covered" >t.Set.complete,</span>M=<span class="cstat-no" title="statement not covered" >t.Set.empty,</span>u=<span class="cstat-no" title="statement not covered" >0;</span>u&lt;this.fields.length;u++){var p=<span class="cstat-no" title="statement not covered" >this.fields[u];<span class="cstat-no" title="statement not covered" ></span>o[p]&amp;&amp;(N=N.intersect(o[p])),a[p]&amp;&amp;(M=M.union(a[p]))}</span>v</span>ar c=<span class="cstat-no" title="statement not covered" >Object.keys(r),</span>g=<span class="cstat-no" title="statement not covered" >[],</span>C=<span class="cstat-no" title="statement not covered" >Object.create(null);<span class="cstat-no" title="statement not covered" ></span>if(n.isNegated()){<span class="cstat-no" title="statement not covered" >c=Object.keys(this.fieldVectors);<span class="cstat-no" title="statement not covered" >f</span>or(var u=<span class="cstat-no" title="statement not covered" >0;</span>u&lt;c.length;u++){var P=<span class="cstat-no" title="statement not covered" >c[u],</span>T=<span class="cstat-no" title="statement not covered" >t.FieldRef.fromString(P);<span class="cstat-no" title="statement not covered" ></span>r[P]=new t.MatchData}</span>}<span class="cstat-no" title="statement not covered" ></span>f</span>or(var u=<span class="cstat-no" title="statement not covered" >0;</span>u&lt;c.length;u++){var T=<span class="cstat-no" title="statement not covered" >t.FieldRef.fromString(c[u]),</span>d=<span class="cstat-no" title="statement not covered" >T.docRef;<span class="cstat-no" title="statement not covered" ></span>if(!!N.contains(d)&amp;&amp;!M.contains(d)){var x=<span class="cstat-no" title="statement not covered" >this.fieldVectors[T],</span>O=<span class="cstat-no" title="statement not covered" >i[T.fieldName].similarity(x),</span>D;<span class="cstat-no" title="statement not covered" >if((D=C[d])!==void 0)<span class="cstat-no" title="statement not covered" >D.score+=O,D.matchData.combine(r[T]);e</span>lse{var L=<span class="cstat-no" title="statement not covered" >{ref:d,score:O,matchData:r[T]};<span class="cstat-no" title="statement not covered" ></span>C[d]=L,g.push(L)}</span>}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn g.sort(<span class="fstat-no" title="function not covered" >fu</span>nction(we,Te){<span class="cstat-no" title="statement not covered" >return Te.score-we.score}</span>)}</span>,t.Index.prototype.toJSON=<span class="fstat-no" title="function not covered" >fu</span>nction(){var e=<span class="cstat-no" title="statement not covered" >Object.keys(this.invertedIndex).sort().map(<span class="fstat-no" title="function not covered" >fu</span>nction(r){<span class="cstat-no" title="statement not covered" >return[r,this.invertedIndex[r]]}</span>,this),</span>n=<span class="cstat-no" title="statement not covered" >Object.keys(this.fieldVectors).map(<span class="fstat-no" title="function not covered" >fu</span>nction(r){<span class="cstat-no" title="statement not covered" >return[r,this.fieldVectors[r].toJSON()]}</span>,this);<span class="cstat-no" title="statement not covered" ></span>return{version:t.version,fields:this.fields,fieldVectors:n,invertedIndex:e,pipeline:this.pipeline.toJSON()}}</span>,t.Index.load=<span class="fstat-no" title="function not covered" >fu</span>nction(e){var n=<span class="cstat-no" title="statement not covered" >{},</span>r=<span class="cstat-no" title="statement not covered" >{},</span>i=<span class="cstat-no" title="statement not covered" >e.fieldVectors,</span>s=<span class="cstat-no" title="statement not covered" >Object.create(null),</span>o=<span class="cstat-no" title="statement not covered" >e.invertedIndex,</span>a=<span class="cstat-no" title="statement not covered" >new t.TokenSet.Builder,</span>u=<span class="cstat-no" title="statement not covered" >t.Pipeline.load(e.pipeline);<span class="cstat-no" title="statement not covered" ></span>e.version!=t.version&amp;&amp;t.utils.warn("Version mismatch when loading serialised index. Current version of lunr '"+t.version+"' does not match serialized index '"+e.version+"'");<span class="cstat-no" title="statement not covered" >f</span>or(var l=<span class="cstat-no" title="statement not covered" >0;</span>l&lt;i.length;l++){var h=<span class="cstat-no" title="statement not covered" >i[l],</span>m=<span class="cstat-no" title="statement not covered" >h[0],</span>v=<span class="cstat-no" title="statement not covered" >h[1];<span class="cstat-no" title="statement not covered" ></span>r[m]=new t.Vector(v)}<span class="cstat-no" title="statement not covered" ></span>f</span>or(var l=<span class="cstat-no" title="statement not covered" >0;</span>l&lt;o.length;l++){var h=<span class="cstat-no" title="statement not covered" >o[l],</span>b=<span class="cstat-no" title="statement not covered" >h[0],</span>y=<span class="cstat-no" title="statement not covered" >h[1];<span class="cstat-no" title="statement not covered" ></span>a.insert(b),s[b]=y}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn a.finish(),n.fields=e.fields,n.fieldVectors=r,n.invertedIndex=s,n.tokenSet=a.root,n.pipeline=u,new t.Index(n)}</span>;<span class="cstat-no" title="statement not covered" >t</span>.Builder=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >this._ref="id",this._fields=Object.create(null),this._documents=Object.create(null),this.invertedIndex=Object.create(null),this.fieldTermFrequencies={},this.fieldLengths={},this.tokenizer=t.tokenizer,this.pipeline=new t.Pipeline,this.searchPipeline=new t.Pipeline,this.documentCount=0,this._b=.75,this._k1=1.2,this.termIndex=0,this.metadataWhitelist=[]}</span>,t.Builder.prototype.ref=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >this._ref=e}</span>,t.Builder.prototype.field=<span class="fstat-no" title="function not covered" >fu</span>nction(e,n){<span class="cstat-no" title="statement not covered" >if(/\//.test(e))<span class="cstat-no" title="statement not covered" >throw new RangeError("Field '"+e+"' contains illegal character '/'");<span class="cstat-no" title="statement not covered" >t</span></span>his._fields[e]=n||{}}</span>,t.Builder.prototype.b=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >e&lt;0?this._b=0:e&gt;1?this._b=1:this._b=e}</span>,t.Builder.prototype.k1=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >this._k1=e}</span>,t.Builder.prototype.add=<span class="fstat-no" title="function not covered" >fu</span>nction(e,n){var r=<span class="cstat-no" title="statement not covered" >e[this._ref],</span>i=<span class="cstat-no" title="statement not covered" >Object.keys(this._fields);<span class="cstat-no" title="statement not covered" ></span>this._documents[r]=n||{},this.documentCount+=1;<span class="cstat-no" title="statement not covered" >f</span>or(var s=<span class="cstat-no" title="statement not covered" >0;</span>s&lt;i.length;s++){var o=<span class="cstat-no" title="statement not covered" >i[s],</span>a=<span class="cstat-no" title="statement not covered" >this._fields[o].extractor,</span>u=<span class="cstat-no" title="statement not covered" >a?a(e):e[o],</span>l=<span class="cstat-no" title="statement not covered" >this.tokenizer(u,{fields:[o]}),</span>h=<span class="cstat-no" title="statement not covered" >this.pipeline.run(l),</span>m=<span class="cstat-no" title="statement not covered" >new t.FieldRef(r,o),</span>v=<span class="cstat-no" title="statement not covered" >Object.create(null);<span class="cstat-no" title="statement not covered" ></span>this.fieldTermFrequencies[m]=v,this.fieldLengths[m]=0,this.fieldLengths[m]+=h.length;<span class="cstat-no" title="statement not covered" >f</span>or(var b=<span class="cstat-no" title="statement not covered" >0;</span>b&lt;h.length;b++){var y=<span class="cstat-no" title="statement not covered" >h[b];<span class="cstat-no" title="statement not covered" ></span>if(v[y]==null&amp;&amp;(v[y]=0),v[y]+=1,this.invertedIndex[y]==null){var E=<span class="cstat-no" title="statement not covered" >Object.create(null);<span class="cstat-no" title="statement not covered" ></span>E._index=this.termIndex,this.termIndex+=1;<span class="cstat-no" title="statement not covered" >f</span>or(var f=<span class="cstat-no" title="statement not covered" >0;</span>f&lt;i.length;f++)<span class="cstat-no" title="statement not covered" >E[i[f]]=Object.create(null);<span class="cstat-no" title="statement not covered" >t</span></span>his.invertedIndex[y]=E}<span class="cstat-no" title="statement not covered" ></span>t</span>his.invertedIndex[y][o][r]==null&amp;&amp;(this.invertedIndex[y][o][r]=Object.create(null));<span class="cstat-no" title="statement not covered" >f</span>or(var p=<span class="cstat-no" title="statement not covered" >0;</span>p&lt;this.metadataWhitelist.length;p++){var w=<span class="cstat-no" title="statement not covered" >this.metadataWhitelist[p],</span>S=<span class="cstat-no" title="statement not covered" >y.metadata[w];<span class="cstat-no" title="statement not covered" ></span>this.invertedIndex[y][o][r][w]==null&amp;&amp;(this.invertedIndex[y][o][r][w]=[]),this.invertedIndex[y][o][r][w].push(S)}</span>}</span>}</span>}</span>,t.Builder.prototype.calculateAverageFieldLengths=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >for(var e=<span class="cstat-no" title="statement not covered" >Object.keys(this.fieldLengths),</span>n=<span class="cstat-no" title="statement not covered" >e.length,</span>r=<span class="cstat-no" title="statement not covered" >{},</span>i=<span class="cstat-no" title="statement not covered" >{},</span>s=<span class="cstat-no" title="statement not covered" >0;</span>s&lt;n;s++){var o=<span class="cstat-no" title="statement not covered" >t.FieldRef.fromString(e[s]),</span>a=<span class="cstat-no" title="statement not covered" >o.fieldName;<span class="cstat-no" title="statement not covered" ></span>i[a]||(i[a]=0),i[a]+=1,r[a]||(r[a]=0),r[a]+=this.fieldLengths[o]}<span class="cstat-no" title="statement not covered" ></span>f</span>or(var u=<span class="cstat-no" title="statement not covered" >Object.keys(this._fields),</span>s=<span class="cstat-no" title="statement not covered" >0;</span>s&lt;u.length;s++){var l=<span class="cstat-no" title="statement not covered" >u[s];<span class="cstat-no" title="statement not covered" ></span>r[l]=r[l]/i[l]}<span class="cstat-no" title="statement not covered" ></span>t</span>his.averageFieldLength=r}</span>,t.Builder.prototype.createFieldVectors=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >for(var e=<span class="cstat-no" title="statement not covered" >{},</span>n=<span class="cstat-no" title="statement not covered" >Object.keys(this.fieldTermFrequencies),</span>r=<span class="cstat-no" title="statement not covered" >n.length,</span>i=<span class="cstat-no" title="statement not covered" >Object.create(null),</span>s=<span class="cstat-no" title="statement not covered" >0;</span>s&lt;r;s++){<span class="cstat-no" title="statement not covered" >for(var o=<span class="cstat-no" title="statement not covered" >t.FieldRef.fromString(n[s]),</span>a=<span class="cstat-no" title="statement not covered" >o.fieldName,</span>u=<span class="cstat-no" title="statement not covered" >this.fieldLengths[o],</span>l=<span class="cstat-no" title="statement not covered" >new t.Vector,</span>h=<span class="cstat-no" title="statement not covered" >this.fieldTermFrequencies[o],</span>m=<span class="cstat-no" title="statement not covered" >Object.keys(h),</span>v=<span class="cstat-no" title="statement not covered" >m.length,</span>b=<span class="cstat-no" title="statement not covered" >this._fields[a].boost||1,</span>y=<span class="cstat-no" title="statement not covered" >this._documents[o.docRef].boost||1,</span>E=<span class="cstat-no" title="statement not covered" >0;</span>E&lt;v;E++){var f=<span class="cstat-no" title="statement not covered" >m[E],</span>p=<span class="cstat-no" title="statement not covered" >h[f],</span>w=<span class="cstat-no" title="statement not covered" >this.invertedIndex[f]._index,</span>S,I,_;<span class="cstat-no" title="statement not covered" >i[f]===void 0?(S=t.idf(this.invertedIndex[f],this.documentCount),i[f]=S):S=i[f],I=S*((this._k1+1)*p)/(this._k1*(1-this._b+this._b*(u/this.averageFieldLength[a]))+p),I*=b,I*=y,_=Math.round(I*1e3)/1e3,l.insert(w,_)}<span class="cstat-no" title="statement not covered" ></span>e</span>[o]=l}<span class="cstat-no" title="statement not covered" ></span>t</span>his.fieldVectors=e}</span>,t.Builder.prototype.createTokenSet=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >this.tokenSet=t.TokenSet.fromArray(Object.keys(this.invertedIndex).sort())}</span>,t.Builder.prototype.build=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.calculateAverageFieldLengths(),this.createFieldVectors(),this.createTokenSet(),new t.Index({invertedIndex:this.invertedIndex,fieldVectors:this.fieldVectors,tokenSet:this.tokenSet,fields:Object.keys(this._fields),pipeline:this.searchPipeline})}</span>,t.Builder.prototype.use=<span class="fstat-no" title="function not covered" >fu</span>nction(e){var n=<span class="cstat-no" title="statement not covered" >Array.prototype.slice.call(arguments,1);<span class="cstat-no" title="statement not covered" ></span>n.unshift(this),e.apply(this,n)}</span>,t.MatchData=<span class="fstat-no" title="function not covered" >fu</span>nction(e,n,r){<span class="cstat-no" title="statement not covered" >for(var i=<span class="cstat-no" title="statement not covered" >Object.create(null),</span>s=<span class="cstat-no" title="statement not covered" >Object.keys(r||{}),</span>o=<span class="cstat-no" title="statement not covered" >0;</span>o&lt;s.length;o++){var a=<span class="cstat-no" title="statement not covered" >s[o];<span class="cstat-no" title="statement not covered" ></span>i[a]=r[a].slice()}<span class="cstat-no" title="statement not covered" ></span>t</span>his.metadata=Object.create(null),e!==void 0&amp;&amp;(this.metadata[e]=Object.create(null),this.metadata[e][n]=i)}</span>,t.MatchData.prototype.combine=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >for(var n=<span class="cstat-no" title="statement not covered" >Object.keys(e.metadata),</span>r=<span class="cstat-no" title="statement not covered" >0;</span>r&lt;n.length;r++){var i=<span class="cstat-no" title="statement not covered" >n[r],</span>s=<span class="cstat-no" title="statement not covered" >Object.keys(e.metadata[i]);<span class="cstat-no" title="statement not covered" ></span>this.metadata[i]==null&amp;&amp;(this.metadata[i]=Object.create(null));<span class="cstat-no" title="statement not covered" >f</span>or(var o=<span class="cstat-no" title="statement not covered" >0;</span>o&lt;s.length;o++){var a=<span class="cstat-no" title="statement not covered" >s[o],</span>u=<span class="cstat-no" title="statement not covered" >Object.keys(e.metadata[i][a]);<span class="cstat-no" title="statement not covered" ></span>this.metadata[i][a]==null&amp;&amp;(this.metadata[i][a]=Object.create(null));<span class="cstat-no" title="statement not covered" >f</span>or(var l=<span class="cstat-no" title="statement not covered" >0;</span>l&lt;u.length;l++){var h=<span class="cstat-no" title="statement not covered" >u[l];<span class="cstat-no" title="statement not covered" ></span>this.metadata[i][a][h]==null?this.metadata[i][a][h]=e.metadata[i][a][h]:this.metadata[i][a][h]=this.metadata[i][a][h].concat(e.metadata[i][a][h])}</span>}</span>}</span>}</span>,t.MatchData.prototype.add=<span class="fstat-no" title="function not covered" >fu</span>nction(e,n,r){<span class="cstat-no" title="statement not covered" >if(!(e in this.metadata)){<span class="cstat-no" title="statement not covered" >this.metadata[e]=Object.create(null),this.metadata[e][n]=r;<span class="cstat-no" title="statement not covered" >r</span>eturn}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!(n in this.metadata[e])){<span class="cstat-no" title="statement not covered" >this.metadata[e][n]=r;<span class="cstat-no" title="statement not covered" >r</span>eturn}<span class="cstat-no" title="statement not covered" ></span>f</span>or(var i=<span class="cstat-no" title="statement not covered" >Object.keys(r),</span>s=<span class="cstat-no" title="statement not covered" >0;</span>s&lt;i.length;s++){var o=<span class="cstat-no" title="statement not covered" >i[s];<span class="cstat-no" title="statement not covered" ></span>o in this.metadata[e][n]?this.metadata[e][n][o]=this.metadata[e][n][o].concat(r[o]):this.metadata[e][n][o]=r[o]}</span>}</span>,t.Query=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >this.clauses=[],this.allFields=e}</span>,t.Query.wildcard=new String("*"),t.Query.wildcard.NONE=0,t.Query.wildcard.LEADING=1,t.Query.wildcard.TRAILING=2,t.Query.presence={OPTIONAL:1,REQUIRED:2,PROHIBITED:3},t.Query.prototype.clause=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return"fields"in e||(e.fields=this.allFields),"boost"in e||(e.boost=1),"usePipeline"in e||(e.usePipeline=!0),"wildcard"in e||(e.wildcard=t.Query.wildcard.NONE),e.wildcard&amp;t.Query.wildcard.LEADING&amp;&amp;e.term.charAt(0)!=t.Query.wildcard&amp;&amp;(e.term="*"+e.term),e.wildcard&amp;t.Query.wildcard.TRAILING&amp;&amp;e.term.slice(-1)!=t.Query.wildcard&amp;&amp;(e.term=""+e.term+"*"),"presence"in e||(e.presence=t.Query.presence.OPTIONAL),this.clauses.push(e),this}</span>,t.Query.prototype.isNegated=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >for(var e=<span class="cstat-no" title="statement not covered" >0;</span>e&lt;this.clauses.length;e++)<span class="cstat-no" title="statement not covered" >if(this.clauses[e].presence!=t.Query.presence.PROHIBITED)<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn!0}</span>,t.Query.prototype.term=<span class="fstat-no" title="function not covered" >fu</span>nction(e,n){<span class="cstat-no" title="statement not covered" >if(Array.isArray(e))<span class="cstat-no" title="statement not covered" >return e.forEach(<span class="fstat-no" title="function not covered" >fu</span>nction(i){<span class="cstat-no" title="statement not covered" >this.term(i,t.utils.clone(n))}</span>,this),this;v</span></span>ar r=<span class="cstat-no" title="statement not covered" >n||{};<span class="cstat-no" title="statement not covered" ></span>return r.term=e.toString(),this.clause(r),this}</span>,t.QueryParseError=<span class="fstat-no" title="function not covered" >fu</span>nction(e,n,r){<span class="cstat-no" title="statement not covered" >this.name="QueryParseError",this.message=e,this.start=n,this.end=r}</span>,t.QueryParseError.prototype=new Error,t.QueryLexer=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >this.lexemes=[],this.str=e,this.length=e.length,this.pos=0,this.start=0,this.escapeCharPositions=[]}</span>,t.QueryLexer.prototype.run=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >for(var e=<span class="cstat-no" title="statement not covered" >t.QueryLexer.lexText;</span>e;)<span class="cstat-no" title="statement not covered" >e=e(this)}</span></span>,t.QueryLexer.prototype.sliceString=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >for(var e=<span class="cstat-no" title="statement not covered" >[],</span>n=<span class="cstat-no" title="statement not covered" >this.start,</span>r=<span class="cstat-no" title="statement not covered" >this.pos,</span>i=<span class="cstat-no" title="statement not covered" >0;</span>i&lt;this.escapeCharPositions.length;i++)<span class="cstat-no" title="statement not covered" >r=this.escapeCharPositions[i],e.push(this.str.slice(n,r)),n=r+1;<span class="cstat-no" title="statement not covered" >r</span></span>eturn e.push(this.str.slice(n,this.pos)),this.escapeCharPositions.length=0,e.join("")}</span>,t.QueryLexer.prototype.emit=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >this.lexemes.push({type:e,str:this.sliceString(),start:this.start,end:this.pos}),this.start=this.pos}</span>,t.QueryLexer.prototype.escapeCharacter=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >this.escapeCharPositions.push(this.pos-1),this.pos+=1}</span>,t.QueryLexer.prototype.next=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >if(this.pos&gt;=this.length)<span class="cstat-no" title="statement not covered" >return t.QueryLexer.EOS;v</span></span>ar e=<span class="cstat-no" title="statement not covered" >this.str.charAt(this.pos);<span class="cstat-no" title="statement not covered" ></span>return this.pos+=1,e}</span>,t.QueryLexer.prototype.width=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.pos-this.start}</span>,t.QueryLexer.prototype.ignore=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >this.start==this.pos&amp;&amp;(this.pos+=1),this.start=this.pos}</span>,t.QueryLexer.prototype.backup=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >this.pos-=1}</span>,t.QueryLexer.prototype.acceptDigitRun=<span class="fstat-no" title="function not covered" >fu</span>nction(){var e,n;<span class="cstat-no" title="statement not covered" >do <span class="cstat-no" title="statement not covered" >e=this.next(),n=e.charCodeAt(0);w</span>hile(n&gt;47&amp;&amp;n&lt;58);<span class="cstat-no" title="statement not covered" >e</span>!=t.QueryLexer.EOS&amp;&amp;this.backup()}</span>,t.QueryLexer.prototype.more=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.pos&lt;this.length}</span>,t.QueryLexer.EOS="EOS",t.QueryLexer.FIELD="FIELD",t.QueryLexer.TERM="TERM",t.QueryLexer.EDIT_DISTANCE="EDIT_DISTANCE",t.QueryLexer.BOOST="BOOST",t.QueryLexer.PRESENCE="PRESENCE",t.QueryLexer.lexField=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return e.backup(),e.emit(t.QueryLexer.FIELD),e.ignore(),t.QueryLexer.lexText}</span>,t.QueryLexer.lexTerm=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >if(e.width()&gt;1&amp;&amp;(e.backup(),e.emit(t.QueryLexer.TERM)),e.ignore(),e.more())<span class="cstat-no" title="statement not covered" >return t.QueryLexer.lexText}</span></span>,t.QueryLexer.lexEditDistance=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return e.ignore(),e.acceptDigitRun(),e.emit(t.QueryLexer.EDIT_DISTANCE),t.QueryLexer.lexText}</span>,t.QueryLexer.lexBoost=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return e.ignore(),e.acceptDigitRun(),e.emit(t.QueryLexer.BOOST),t.QueryLexer.lexText}</span>,t.QueryLexer.lexEOS=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >e.width()&gt;0&amp;&amp;e.emit(t.QueryLexer.TERM)}</span>,t.QueryLexer.termSeparator=t.tokenizer.separator,t.QueryLexer.lexText=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >for(;;){var n=<span class="cstat-no" title="statement not covered" >e.next();<span class="cstat-no" title="statement not covered" ></span>if(n==t.QueryLexer.EOS)<span class="cstat-no" title="statement not covered" >return t.QueryLexer.lexEOS;<span class="cstat-no" title="statement not covered" >i</span></span>f(n.charCodeAt(0)==92){<span class="cstat-no" title="statement not covered" >e.escapeCharacter();<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>i</span>f(n==":")<span class="cstat-no" title="statement not covered" >return t.QueryLexer.lexField;<span class="cstat-no" title="statement not covered" >i</span></span>f(n=="~")<span class="cstat-no" title="statement not covered" >return e.backup(),e.width()&gt;0&amp;&amp;e.emit(t.QueryLexer.TERM),t.QueryLexer.lexEditDistance;<span class="cstat-no" title="statement not covered" >i</span></span>f(n=="^")<span class="cstat-no" title="statement not covered" >return e.backup(),e.width()&gt;0&amp;&amp;e.emit(t.QueryLexer.TERM),t.QueryLexer.lexBoost;<span class="cstat-no" title="statement not covered" >i</span></span>f(n=="+"&amp;&amp;e.width()===1||n=="-"&amp;&amp;e.width()===1)<span class="cstat-no" title="statement not covered" >return e.emit(t.QueryLexer.PRESENCE),t.QueryLexer.lexText;<span class="cstat-no" title="statement not covered" >i</span></span>f(n.match(t.QueryLexer.termSeparator))<span class="cstat-no" title="statement not covered" >return t.QueryLexer.lexTerm}</span></span>}</span>,t.QueryParser=<span class="fstat-no" title="function not covered" >fu</span>nction(e,n){<span class="cstat-no" title="statement not covered" >this.lexer=new t.QueryLexer(e),this.query=n,this.currentClause={},this.lexemeIdx=0}</span>,t.QueryParser.prototype.parse=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >this.lexer.run(),this.lexemes=this.lexer.lexemes;<span class="cstat-no" title="statement not covered" >f</span>or(var e=<span class="cstat-no" title="statement not covered" >t.QueryParser.parseClause;</span>e;)<span class="cstat-no" title="statement not covered" >e=e(this);<span class="cstat-no" title="statement not covered" >r</span></span>eturn this.query}</span>,t.QueryParser.prototype.peekLexeme=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.lexemes[this.lexemeIdx]}</span>,t.QueryParser.prototype.consumeLexeme=<span class="fstat-no" title="function not covered" >fu</span>nction(){var e=<span class="cstat-no" title="statement not covered" >this.peekLexeme();<span class="cstat-no" title="statement not covered" ></span>return this.lexemeIdx+=1,e}</span>,t.QueryParser.prototype.nextClause=<span class="fstat-no" title="function not covered" >fu</span>nction(){var e=<span class="cstat-no" title="statement not covered" >this.currentClause;<span class="cstat-no" title="statement not covered" ></span>this.query.clause(e),this.currentClause={}}</span>,t.QueryParser.parseClause=<span class="fstat-no" title="function not covered" >fu</span>nction(e){var n=<span class="cstat-no" title="statement not covered" >e.peekLexeme();<span class="cstat-no" title="statement not covered" ></span>if(n!=null)<span class="cstat-no" title="statement not covered" >switch(n.type){case t.QueryLexer.PRESENCE:<span class="cstat-no" title="statement not covered" >return t.QueryParser.parsePresence;c</span>ase t.QueryLexer.FIELD:<span class="cstat-no" title="statement not covered" >return t.QueryParser.parseField;c</span>ase t.QueryLexer.TERM:<span class="cstat-no" title="statement not covered" >return t.QueryParser.parseTerm;d</span>efault:var r=<span class="cstat-no" title="statement not covered" >"expected either a field or a term, found "+n.type;<span class="cstat-no" title="statement not covered" ></span>throw n.str.length&gt;=1&amp;&amp;(r+=" with value '"+n.str+"'"),new t.QueryParseError(r,n.start,n.end)}</span>}</span></span>,t.QueryParser.parsePresence=<span class="fstat-no" title="function not covered" >fu</span>nction(e){var n=<span class="cstat-no" title="statement not covered" >e.consumeLexeme();<span class="cstat-no" title="statement not covered" ></span>if(n!=null){<span class="cstat-no" title="statement not covered" >switch(n.str){case"-":<span class="cstat-no" title="statement not covered" >e.currentClause.presence=t.Query.presence.PROHIBITED;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"+":<span class="cstat-no" title="statement not covered" >e.currentClause.presence=t.Query.presence.REQUIRED;<span class="cstat-no" title="statement not covered" >b</span>reak;d</span>efault:var r=<span class="cstat-no" title="statement not covered" >"unrecognised presence operator'"+n.str+"'";<span class="cstat-no" title="statement not covered" ></span>throw new t.QueryParseError(r,n.start,n.end)}</span>v</span>ar i=<span class="cstat-no" title="statement not covered" >e.peekLexeme();<span class="cstat-no" title="statement not covered" ></span>if(i==null){var r=<span class="cstat-no" title="statement not covered" >"expecting term or field, found nothing";<span class="cstat-no" title="statement not covered" ></span>throw new t.QueryParseError(r,n.start,n.end)}<span class="cstat-no" title="statement not covered" ></span>s</span>witch(i.type){case t.QueryLexer.FIELD:<span class="cstat-no" title="statement not covered" >return t.QueryParser.parseField;c</span>ase t.QueryLexer.TERM:<span class="cstat-no" title="statement not covered" >return t.QueryParser.parseTerm;d</span>efault:var r=<span class="cstat-no" title="statement not covered" >"expecting term or field, found '"+i.type+"'";<span class="cstat-no" title="statement not covered" ></span>throw new t.QueryParseError(r,i.start,i.end)}</span>}</span>}</span>,t.QueryParser.parseField=<span class="fstat-no" title="function not covered" >fu</span>nction(e){var n=<span class="cstat-no" title="statement not covered" >e.consumeLexeme();<span class="cstat-no" title="statement not covered" ></span>if(n!=null){<span class="cstat-no" title="statement not covered" >if(e.query.allFields.indexOf(n.str)==-1){var r=<span class="cstat-no" title="statement not covered" >e.query.allFields.map(<span class="fstat-no" title="function not covered" >fu</span>nction(o){<span class="cstat-no" title="statement not covered" >return"'"+o+"'"}</span>).join(", "),</span>i=<span class="cstat-no" title="statement not covered" >"unrecognised field '"+n.str+"', possible fields: "+r;<span class="cstat-no" title="statement not covered" ></span>throw new t.QueryParseError(i,n.start,n.end)}<span class="cstat-no" title="statement not covered" ></span>e</span>.currentClause.fields=[n.str];v</span>ar s=<span class="cstat-no" title="statement not covered" >e.peekLexeme();<span class="cstat-no" title="statement not covered" ></span>if(s==null){var i=<span class="cstat-no" title="statement not covered" >"expecting term, found nothing";<span class="cstat-no" title="statement not covered" ></span>throw new t.QueryParseError(i,n.start,n.end)}<span class="cstat-no" title="statement not covered" ></span>s</span>witch(s.type){case t.QueryLexer.TERM:<span class="cstat-no" title="statement not covered" >return t.QueryParser.parseTerm;d</span>efault:var i=<span class="cstat-no" title="statement not covered" >"expecting term, found '"+s.type+"'";<span class="cstat-no" title="statement not covered" ></span>throw new t.QueryParseError(i,s.start,s.end)}</span>}</span>}</span>,t.QueryParser.parseTerm=<span class="fstat-no" title="function not covered" >fu</span>nction(e){var n=<span class="cstat-no" title="statement not covered" >e.consumeLexeme();<span class="cstat-no" title="statement not covered" ></span>if(n!=null){<span class="cstat-no" title="statement not covered" >e.currentClause.term=n.str.toLowerCase(),n.str.indexOf("*")!=-1&amp;&amp;(e.currentClause.usePipeline=!1);v</span>ar r=<span class="cstat-no" title="statement not covered" >e.peekLexeme();<span class="cstat-no" title="statement not covered" ></span>if(r==null){<span class="cstat-no" title="statement not covered" >e.nextClause();<span class="cstat-no" title="statement not covered" >r</span>eturn}<span class="cstat-no" title="statement not covered" ></span>s</span>witch(r.type){case t.QueryLexer.TERM:<span class="cstat-no" title="statement not covered" >return e.nextClause(),t.QueryParser.parseTerm;c</span>ase t.QueryLexer.FIELD:<span class="cstat-no" title="statement not covered" >return e.nextClause(),t.QueryParser.parseField;c</span>ase t.QueryLexer.EDIT_DISTANCE:<span class="cstat-no" title="statement not covered" >return t.QueryParser.parseEditDistance;c</span>ase t.QueryLexer.BOOST:<span class="cstat-no" title="statement not covered" >return t.QueryParser.parseBoost;c</span>ase t.QueryLexer.PRESENCE:<span class="cstat-no" title="statement not covered" >return e.nextClause(),t.QueryParser.parsePresence;d</span>efault:var i=<span class="cstat-no" title="statement not covered" >"Unexpected lexeme type '"+r.type+"'";<span class="cstat-no" title="statement not covered" ></span>throw new t.QueryParseError(i,r.start,r.end)}</span>}</span>}</span>,t.QueryParser.parseEditDistance=<span class="fstat-no" title="function not covered" >fu</span>nction(e){var n=<span class="cstat-no" title="statement not covered" >e.consumeLexeme();<span class="cstat-no" title="statement not covered" ></span>if(n!=null){var r=<span class="cstat-no" title="statement not covered" >parseInt(n.str,10);<span class="cstat-no" title="statement not covered" ></span>if(isNaN(r)){var i=<span class="cstat-no" title="statement not covered" >"edit distance must be numeric";<span class="cstat-no" title="statement not covered" ></span>throw new t.QueryParseError(i,n.start,n.end)}<span class="cstat-no" title="statement not covered" ></span>e</span>.currentClause.editDistance=r;v</span>ar s=<span class="cstat-no" title="statement not covered" >e.peekLexeme();<span class="cstat-no" title="statement not covered" ></span>if(s==null){<span class="cstat-no" title="statement not covered" >e.nextClause();<span class="cstat-no" title="statement not covered" >r</span>eturn}<span class="cstat-no" title="statement not covered" ></span>s</span>witch(s.type){case t.QueryLexer.TERM:<span class="cstat-no" title="statement not covered" >return e.nextClause(),t.QueryParser.parseTerm;c</span>ase t.QueryLexer.FIELD:<span class="cstat-no" title="statement not covered" >return e.nextClause(),t.QueryParser.parseField;c</span>ase t.QueryLexer.EDIT_DISTANCE:<span class="cstat-no" title="statement not covered" >return t.QueryParser.parseEditDistance;c</span>ase t.QueryLexer.BOOST:<span class="cstat-no" title="statement not covered" >return t.QueryParser.parseBoost;c</span>ase t.QueryLexer.PRESENCE:<span class="cstat-no" title="statement not covered" >return e.nextClause(),t.QueryParser.parsePresence;d</span>efault:var i=<span class="cstat-no" title="statement not covered" >"Unexpected lexeme type '"+s.type+"'";<span class="cstat-no" title="statement not covered" ></span>throw new t.QueryParseError(i,s.start,s.end)}</span>}</span>}</span>,t.QueryParser.parseBoost=<span class="fstat-no" title="function not covered" >fu</span>nction(e){var n=<span class="cstat-no" title="statement not covered" >e.consumeLexeme();<span class="cstat-no" title="statement not covered" ></span>if(n!=null){var r=<span class="cstat-no" title="statement not covered" >parseInt(n.str,10);<span class="cstat-no" title="statement not covered" ></span>if(isNaN(r)){var i=<span class="cstat-no" title="statement not covered" >"boost must be numeric";<span class="cstat-no" title="statement not covered" ></span>throw new t.QueryParseError(i,n.start,n.end)}<span class="cstat-no" title="statement not covered" ></span>e</span>.currentClause.boost=r;v</span>ar s=<span class="cstat-no" title="statement not covered" >e.peekLexeme();<span class="cstat-no" title="statement not covered" ></span>if(s==null){<span class="cstat-no" title="statement not covered" >e.nextClause();<span class="cstat-no" title="statement not covered" >r</span>eturn}<span class="cstat-no" title="statement not covered" ></span>s</span>witch(s.type){case t.QueryLexer.TERM:<span class="cstat-no" title="statement not covered" >return e.nextClause(),t.QueryParser.parseTerm;c</span>ase t.QueryLexer.FIELD:<span class="cstat-no" title="statement not covered" >return e.nextClause(),t.QueryParser.parseField;c</span>ase t.QueryLexer.EDIT_DISTANCE:<span class="cstat-no" title="statement not covered" >return t.QueryParser.parseEditDistance;c</span>ase t.QueryLexer.BOOST:<span class="cstat-no" title="statement not covered" >return t.QueryParser.parseBoost;c</span>ase t.QueryLexer.PRESENCE:<span class="cstat-no" title="statement not covered" >return e.nextClause(),t.QueryParser.parsePresence;d</span>efault:var i=<span class="cstat-no" title="statement not covered" >"Unexpected lexeme type '"+s.type+"'";<span class="cstat-no" title="statement not covered" ></span>throw new t.QueryParseError(i,s.start,s.end)}</span>}</span>}</span>,<span class="fstat-no" title="function not covered" >fu</span>nction(e,n){<span class="cstat-no" title="statement not covered" >typeof define=="function"&amp;&amp;define.amd?define(n):typeof ce=="object"?he.exports=n():e.lunr=n()}</span>(this,<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return t}</span>)}</span>)()});var le=<span class="cstat-no" title="statement not covered" >[];</span>function <span class="fstat-no" title="function not covered" >j(</span>t,e){<span class="cstat-no" title="statement not covered" >le.push({selector:e,constructor:t})}</span>var Y=<span class="cstat-no" title="statement not covered" >class{<span class="fstat-no" title="function not covered" >co</span>nstructor(){<span class="cstat-no" title="statement not covered" >this.createComponents(document.body)}<span class="fstat-no" title="function not covered" ></span>cr</span>eateComponents(e){<span class="cstat-no" title="statement not covered" >le.forEach(<span class="fstat-no" title="function not covered" >n=</span>&gt;{<span class="cstat-no" title="statement not covered" >e.querySelectorAll(n.selector).forEach(<span class="fstat-no" title="function not covered" >r=</span>&gt;{<span class="cstat-no" title="statement not covered" >r.dataset.hasInstance||(new n.constructor({el:r}),r.dataset.hasInstance=String(!0))}</span>)}</span>)}</span>};</span>var k=<span class="cstat-no" title="statement not covered" >class{<span class="fstat-no" title="function not covered" >co</span>nstructor(e){<span class="cstat-no" title="statement not covered" >this.el=e.el}</span>};</span>var J=<span class="cstat-no" title="statement not covered" >class{<span class="fstat-no" title="function not covered" >co</span>nstructor(){<span class="cstat-no" title="statement not covered" >this.listeners={}}<span class="fstat-no" title="function not covered" ></span>ad</span>dEventListener(e,n){<span class="cstat-no" title="statement not covered" >e in this.listeners||(this.listeners[e]=[]),this.listeners[e].push(n)}<span class="fstat-no" title="function not covered" ></span>re</span>moveEventListener(e,n){<span class="cstat-no" title="statement not covered" >if(!(e in this.listeners))<span class="cstat-no" title="statement not covered" >return;l</span></span>et r=<span class="cstat-no" title="statement not covered" >this.listeners[e];<span class="cstat-no" title="statement not covered" ></span>for(let i=<span class="cstat-no" title="statement not covered" >0,</span>s=<span class="cstat-no" title="statement not covered" >r.length;</span>i&lt;s;i++)<span class="cstat-no" title="statement not covered" >if(r[i]===n){<span class="cstat-no" title="statement not covered" >r.splice(i,1);<span class="cstat-no" title="statement not covered" >r</span>eturn}</span>}<span class="fstat-no" title="function not covered" ></span></span>di</span>spatchEvent(e){<span class="cstat-no" title="statement not covered" >if(!(e.type in this.listeners))<span class="cstat-no" title="statement not covered" >return!0;l</span></span>et n=<span class="cstat-no" title="statement not covered" >this.listeners[e.type].slice();<span class="cstat-no" title="statement not covered" ></span>for(let r=<span class="cstat-no" title="statement not covered" >0,</span>i=<span class="cstat-no" title="statement not covered" >n.length;</span>r&lt;i;r++)<span class="cstat-no" title="statement not covered" >n[r].call(this,e);<span class="cstat-no" title="statement not covered" >r</span></span>eturn!e.defaultPrevented}</span>};</span>var ne=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e=<span class="branch-0 cbranch-no" title="branch not covered" >100)</span>=&gt;{let n=<span class="cstat-no" title="statement not covered" >Date.now();<span class="cstat-no" title="statement not covered" ></span>return<span class="fstat-no" title="function not covered" >(.</span>..r)=&gt;{<span class="cstat-no" title="statement not covered" >n+e-Date.now()&lt;0&amp;&amp;(t(...r),n=Date.now())}</span>}</span>;</span>var re=<span class="cstat-no" title="statement not covered" >class extends J{<span class="fstat-no" title="function not covered" >co</span>nstructor(){<span class="cstat-no" title="statement not covered" >super();<span class="cstat-no" title="statement not covered" >t</span>his.scrollTop=0;<span class="cstat-no" title="statement not covered" >t</span>his.lastY=0;<span class="cstat-no" title="statement not covered" >t</span>his.width=0;<span class="cstat-no" title="statement not covered" >t</span>his.height=0;<span class="cstat-no" title="statement not covered" >t</span>his.showToolbar=!0;<span class="cstat-no" title="statement not covered" >t</span>his.toolbar=document.querySelector(".tsd-page-toolbar"),this.navigation=document.querySelector(".col-menu"),window.addEventListener("scroll",ne(<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >this.onScroll(),</span>10)),window.addEventListener("resize",ne(<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >this.onResize(),</span>10)),this.searchInput=document.querySelector("#tsd-search input"),this.searchInput&amp;&amp;this.searchInput.addEventListener("focus",<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >this.hideShowToolbar()}</span>),this.onResize(),this.onScroll()}<span class="fstat-no" title="function not covered" ></span>tr</span>iggerResize(){let n=<span class="cstat-no" title="statement not covered" >new CustomEvent("resize",{detail:{width:this.width,height:this.height}});<span class="cstat-no" title="statement not covered" ></span>this.dispatchEvent(n)}<span class="fstat-no" title="function not covered" ></span>on</span>Resize(){<span class="cstat-no" title="statement not covered" >this.width=window.innerWidth||0,this.height=window.innerHeight||0;l</span>et n=<span class="cstat-no" title="statement not covered" >new CustomEvent("resize",{detail:{width:this.width,height:this.height}});<span class="cstat-no" title="statement not covered" ></span>this.dispatchEvent(n)}<span class="fstat-no" title="function not covered" ></span>on</span>Scroll(){<span class="cstat-no" title="statement not covered" >this.scrollTop=window.scrollY||0;l</span>et n=<span class="cstat-no" title="statement not covered" >new CustomEvent("scroll",{detail:{scrollTop:this.scrollTop}});<span class="cstat-no" title="statement not covered" ></span>this.dispatchEvent(n),this.hideShowToolbar()}<span class="fstat-no" title="function not covered" ></span>hi</span>deShowToolbar(){let n=<span class="cstat-no" title="statement not covered" >this.showToolbar;<span class="cstat-no" title="statement not covered" ></span>this.showToolbar=this.lastY&gt;=this.scrollTop||this.scrollTop&lt;=0||!!this.searchInput&amp;&amp;this.searchInput===document.activeElement,n!==this.showToolbar&amp;&amp;(this.toolbar.classList.toggle("tsd-page-toolbar--hide"),this.navigation?.classList.toggle("col-menu--hide")),this.lastY=this.scrollTop}</span>},</span>R=<span class="cstat-no" title="statement not covered" >re;<span class="cstat-no" title="statement not covered" ></span>R.instance=new re;v</span>ar X=<span class="cstat-no" title="statement not covered" >class extends k{<span class="fstat-no" title="function not covered" >co</span>nstructor(n){<span class="cstat-no" title="statement not covered" >super(n);<span class="cstat-no" title="statement not covered" >t</span>his.anchors=[];<span class="cstat-no" title="statement not covered" >t</span>his.index=-1;<span class="cstat-no" title="statement not covered" >R</span>.instance.addEventListener("resize",<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >this.onResize())</span>,R.instance.addEventListener("scroll",<span class="fstat-no" title="function not covered" >r=</span>&gt;<span class="cstat-no" title="statement not covered" >this.onScroll(r))</span>,this.createAnchors()}<span class="fstat-no" title="function not covered" ></span>cr</span>eateAnchors(){let n=<span class="cstat-no" title="statement not covered" >window.location.href;<span class="cstat-no" title="statement not covered" ></span>n.indexOf("#")!=-1&amp;&amp;(n=n.substring(0,n.indexOf("#"))),this.el.querySelectorAll("a").forEach(<span class="fstat-no" title="function not covered" >r=</span>&gt;{let i=<span class="cstat-no" title="statement not covered" >r.href;<span class="cstat-no" title="statement not covered" ></span>if(i.indexOf("#")==-1||i.substring(0,n.length)!=n)<span class="cstat-no" title="statement not covered" >return;l</span></span>et s=<span class="cstat-no" title="statement not covered" >i.substring(i.indexOf("#")+1),</span>o=<span class="cstat-no" title="statement not covered" >document.querySelector("a.tsd-anchor[name="+s+"]"),</span>a=<span class="cstat-no" title="statement not covered" >r.parentNode;<span class="cstat-no" title="statement not covered" ></span>!o||!a||this.anchors.push({link:a,anchor:o,position:0})}</span>),this.onResize()}<span class="fstat-no" title="function not covered" ></span>on</span>Resize(){let n;<span class="cstat-no" title="statement not covered" >for(let i=<span class="cstat-no" title="statement not covered" >0,</span>s=<span class="cstat-no" title="statement not covered" >this.anchors.length;</span>i&lt;s;i++){<span class="cstat-no" title="statement not covered" >n=this.anchors[i];l</span>et o=<span class="cstat-no" title="statement not covered" >n.anchor.getBoundingClientRect();<span class="cstat-no" title="statement not covered" ></span>n.position=o.top+document.body.scrollTop}<span class="cstat-no" title="statement not covered" ></span>t</span>his.anchors.sort(<span class="fstat-no" title="function not covered" >(i</span>,s)=&gt;<span class="cstat-no" title="statement not covered" >i.position-s.position)</span>;l</span>et r=<span class="cstat-no" title="statement not covered" >new CustomEvent("scroll",{detail:{scrollTop:R.instance.scrollTop}});<span class="cstat-no" title="statement not covered" ></span>this.onScroll(r)}<span class="fstat-no" title="function not covered" ></span>on</span>Scroll(n){let r=<span class="cstat-no" title="statement not covered" >n.detail.scrollTop+5,</span>i=<span class="cstat-no" title="statement not covered" >this.anchors,</span>s=<span class="cstat-no" title="statement not covered" >i.length-1,</span>o=<span class="cstat-no" title="statement not covered" >this.index;<span class="cstat-no" title="statement not covered" ></span>for(;o&gt;-1&amp;&amp;i[o].position&gt;r;)<span class="cstat-no" title="statement not covered" >o-=1;<span class="cstat-no" title="statement not covered" >f</span></span>or(;o&lt;s&amp;&amp;i[o+1].position&lt;r;)<span class="cstat-no" title="statement not covered" >o+=1;<span class="cstat-no" title="statement not covered" >t</span></span>his.index!=o&amp;&amp;(this.index&gt;-1&amp;&amp;this.anchors[this.index].link.classList.remove("focus"),this.index=o,this.index&gt;-1&amp;&amp;this.anchors[this.index].link.classList.add("focus"))}</span>};</span>var ue=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e=<span class="branch-0 cbranch-no" title="branch not covered" >100)</span>=&gt;{let n;<span class="cstat-no" title="statement not covered" >return<span class="fstat-no" title="function not covered" >(.</span>..r)=&gt;{<span class="cstat-no" title="statement not covered" >clearTimeout(n),n=setTimeout(<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >t(r),</span>e)}</span>}</span>;</span>var me=<span class="cstat-no" title="statement not covered" >De(de());</span>function <span class="fstat-no" title="function not covered" >ve(</span>){let t=<span class="cstat-no" title="statement not covered" >document.getElementById("tsd-search");<span class="cstat-no" title="statement not covered" ></span>if(!t)<span class="cstat-no" title="statement not covered" >return;l</span></span>et e=<span class="cstat-no" title="statement not covered" >document.getElementById("search-script");<span class="cstat-no" title="statement not covered" ></span>t.classList.add("loading"),e&amp;&amp;(e.addEventListener("error",<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >t.classList.remove("loading"),t.classList.add("failure")}</span>),e.addEventListener("load",<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >t.classList.remove("loading"),t.classList.add("ready")}</span>),window.searchData&amp;&amp;t.classList.remove("loading"));l</span>et n=<span class="cstat-no" title="statement not covered" >document.querySelector("#tsd-search input"),</span>r=<span class="cstat-no" title="statement not covered" >document.querySelector("#tsd-search .results");<span class="cstat-no" title="statement not covered" ></span>if(!n||!r)<span class="cstat-no" title="statement not covered" >throw new Error("The input field or the result list wrapper was not found");l</span></span>et i=<span class="cstat-no" title="statement not covered" >!1;<span class="cstat-no" title="statement not covered" ></span>r.addEventListener("mousedown",<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >i=!0)</span>,r.addEventListener("mouseup",<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >i=!1,t.classList.remove("has-focus")}</span>),n.addEventListener("focus",<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >t.classList.add("has-focus"))</span>,n.addEventListener("blur",<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >i||(i=!1,t.classList.remove("has-focus"))}</span>);l</span>et s=<span class="cstat-no" title="statement not covered" >{base:t.dataset.base+"/"};<span class="cstat-no" title="statement not covered" ></span>Fe(t,r,n,s)}</span>function <span class="fstat-no" title="function not covered" >Fe(</span>t,e,n,r){<span class="cstat-no" title="statement not covered" >n.addEventListener("input",ue(<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >Ae(t,e,n,r)}</span>,200));l</span>et i=<span class="cstat-no" title="statement not covered" >!1;<span class="cstat-no" title="statement not covered" ></span>n.addEventListener("keydown",<span class="fstat-no" title="function not covered" >s=</span>&gt;{<span class="cstat-no" title="statement not covered" >i=!0,s.key=="Enter"?Ve(e,n):s.key=="Escape"?n.blur():s.key=="ArrowUp"?fe(e,-1):s.key==="ArrowDown"?fe(e,1):i=!1}</span>),n.addEventListener("keypress",<span class="fstat-no" title="function not covered" >s=</span>&gt;{<span class="cstat-no" title="statement not covered" >i&amp;&amp;s.preventDefault()}</span>),document.body.addEventListener("keydown",<span class="fstat-no" title="function not covered" >s=</span>&gt;{<span class="cstat-no" title="statement not covered" >s.altKey||s.ctrlKey||s.metaKey||!n.matches(":focus")&amp;&amp;s.key==="/"&amp;&amp;(n.focus(),s.preventDefault())}</span>)}</span>function <span class="fstat-no" title="function not covered" >He(</span>t,e){<span class="cstat-no" title="statement not covered" >t.index||window.searchData&amp;&amp;(e.classList.remove("loading"),e.classList.add("ready"),t.data=window.searchData,t.index=me.Index.load(window.searchData.index))}</span>function <span class="fstat-no" title="function not covered" >Ae(</span>t,e,n,r){<span class="cstat-no" title="statement not covered" >if(He(r,t),!r.index||!r.data)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >e</span></span>.textContent="";l</span>et i=<span class="cstat-no" title="statement not covered" >n.value.trim(),</span>s=<span class="cstat-no" title="statement not covered" >i?r.index.search(`*${i}*`):[];<span class="cstat-no" title="statement not covered" ></span>for(let o=<span class="cstat-no" title="statement not covered" >0;</span>o&lt;s.length;o++){let a=<span class="cstat-no" title="statement not covered" >s[o],</span>u=<span class="cstat-no" title="statement not covered" >r.data.rows[Number(a.ref)],</span>l=<span class="cstat-no" title="statement not covered" >1;<span class="cstat-no" title="statement not covered" ></span>u.name.toLowerCase().startsWith(i.toLowerCase())&amp;&amp;(l*=1+1/(1+Math.abs(u.name.length-i.length))),a.score*=l}<span class="cstat-no" title="statement not covered" ></span>s</span>.sort(<span class="fstat-no" title="function not covered" >(o</span>,a)=&gt;<span class="cstat-no" title="statement not covered" >a.score-o.score)</span>;<span class="cstat-no" title="statement not covered" >f</span>or(let o=<span class="cstat-no" title="statement not covered" >0,</span>a=<span class="cstat-no" title="statement not covered" >Math.min(10,s.length);</span>o&lt;a;o++){let u=<span class="cstat-no" title="statement not covered" >r.data.rows[Number(s[o].ref)],</span>l=<span class="cstat-no" title="statement not covered" >pe(u.name,i);<span class="cstat-no" title="statement not covered" ></span>globalThis.DEBUG_SEARCH_WEIGHTS&amp;&amp;(l+=` (score: ${s[o].score.toFixed(2)})`),u.parent&amp;&amp;(l=`&lt;span class="parent"&gt;${pe(u.parent,i)}.&lt;/span&gt;${l}`);l</span>et h=<span class="cstat-no" title="statement not covered" >document.createElement("li");<span class="cstat-no" title="statement not covered" ></span>h.classList.value=u.classes??"";l</span>et m=<span class="cstat-no" title="statement not covered" >document.createElement("a");<span class="cstat-no" title="statement not covered" ></span>m.href=r.base+u.url,m.innerHTML=l,h.append(m),e.appendChild(h)}</span>}</span>function <span class="fstat-no" title="function not covered" >fe(</span>t,e){let n=<span class="cstat-no" title="statement not covered" >t.querySelector(".current");<span class="cstat-no" title="statement not covered" ></span>if(!n)<span class="cstat-no" title="statement not covered" >n=t.querySelector(e==1?"li:first-child":"li:last-child"),n&amp;&amp;n.classList.add("current");e</span>lse{let r=<span class="cstat-no" title="statement not covered" >n;<span class="cstat-no" title="statement not covered" ></span>if(e===1)<span class="cstat-no" title="statement not covered" >do <span class="cstat-no" title="statement not covered" >r=r.nextElementSibling??void 0;w</span>hile(r instanceof HTMLElement&amp;&amp;r.offsetParent==null);e</span>lse <span class="cstat-no" title="statement not covered" >do <span class="cstat-no" title="statement not covered" >r=r.previousElementSibling??void 0;w</span>hile(r instanceof HTMLElement&amp;&amp;r.offsetParent==null);<span class="cstat-no" title="statement not covered" >r</span></span>&amp;&amp;(n.classList.remove("current"),r.classList.add("current"))}</span>}</span>function <span class="fstat-no" title="function not covered" >Ve(</span>t,e){let n=<span class="cstat-no" title="statement not covered" >t.querySelector(".current");<span class="cstat-no" title="statement not covered" ></span>if(n||(n=t.querySelector("li:first-child")),n){let r=<span class="cstat-no" title="statement not covered" >n.querySelector("a");<span class="cstat-no" title="statement not covered" ></span>r&amp;&amp;(window.location.href=r.href),e.blur()}</span>}</span>function <span class="fstat-no" title="function not covered" >pe(</span>t,e){<span class="cstat-no" title="statement not covered" >if(e==="")<span class="cstat-no" title="statement not covered" >return t;l</span></span>et n=<span class="cstat-no" title="statement not covered" >t.toLocaleLowerCase(),</span>r=<span class="cstat-no" title="statement not covered" >e.toLocaleLowerCase(),</span>i=<span class="cstat-no" title="statement not covered" >[],</span>s=<span class="cstat-no" title="statement not covered" >0,</span>o=<span class="cstat-no" title="statement not covered" >n.indexOf(r);<span class="cstat-no" title="statement not covered" ></span>for(;o!=-1;)<span class="cstat-no" title="statement not covered" >i.push(ie(t.substring(s,o)),`&lt;b&gt;${ie(t.substring(o,o+r.length))}&lt;/b&gt;`),s=o+r.length,o=n.indexOf(r,s);<span class="cstat-no" title="statement not covered" >r</span></span>eturn i.push(ie(t.substring(s))),i.join("")}</span>var Ne=<span class="cstat-no" title="statement not covered" >{"&amp;":"&amp;amp;","&lt;":"&amp;lt;","&gt;":"&amp;gt;","'":"&amp;#039;",'"':"&amp;quot;"};</span>function <span class="fstat-no" title="function not covered" >ie(</span>t){<span class="cstat-no" title="statement not covered" >return t.replace(/[&amp;&lt;&gt;"'"]/g,<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >Ne[e])</span>}</span>var F=<span class="cstat-no" title="statement not covered" >"mousedown",</span>ye=<span class="cstat-no" title="statement not covered" >"mousemove",</span>B=<span class="cstat-no" title="statement not covered" >"mouseup",</span>Z=<span class="cstat-no" title="statement not covered" >{x:0,y:0},</span>ge=<span class="cstat-no" title="statement not covered" >!1,</span>se=<span class="cstat-no" title="statement not covered" >!1,</span>je=<span class="cstat-no" title="statement not covered" >!1,</span>H=<span class="cstat-no" title="statement not covered" >!1,</span>xe=<span class="cstat-no" title="statement not covered" >/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);<span class="cstat-no" title="statement not covered" ></span>document.documentElement.classList.add(xe?"is-mobile":"not-mobile");<span class="cstat-no" title="statement not covered" >x</span>e&amp;&amp;"ontouchstart"in document.documentElement&amp;&amp;(je=!0,F="touchstart",ye="touchmove",B="touchend");<span class="cstat-no" title="statement not covered" >d</span>ocument.addEventListener(F,<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >se=!0,H=!1;l</span>et e=<span class="cstat-no" title="statement not covered" >F=="touchstart"?t.targetTouches[0]:t;<span class="cstat-no" title="statement not covered" ></span>Z.y=e.pageY||0,Z.x=e.pageX||0}</span>);<span class="cstat-no" title="statement not covered" >d</span>ocument.addEventListener(ye,<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >if(!!se&amp;&amp;!H){let e=<span class="cstat-no" title="statement not covered" >F=="touchstart"?t.targetTouches[0]:t,</span>n=<span class="cstat-no" title="statement not covered" >Z.x-(e.pageX||0),</span>r=<span class="cstat-no" title="statement not covered" >Z.y-(e.pageY||0);<span class="cstat-no" title="statement not covered" ></span>H=Math.sqrt(n*n+r*r)&gt;10}</span>}</span>);<span class="cstat-no" title="statement not covered" >d</span>ocument.addEventListener(B,<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >se=!1}</span>);<span class="cstat-no" title="statement not covered" >d</span>ocument.addEventListener("click",<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >ge&amp;&amp;(t.preventDefault(),t.stopImmediatePropagation(),ge=!1)}</span>);v</span>ar K=<span class="cstat-no" title="statement not covered" >class extends k{<span class="fstat-no" title="function not covered" >co</span>nstructor(n){<span class="cstat-no" title="statement not covered" >super(n);<span class="cstat-no" title="statement not covered" >t</span>his.className=this.el.dataset.toggle||"",this.el.addEventListener(B,<span class="fstat-no" title="function not covered" >r=</span>&gt;<span class="cstat-no" title="statement not covered" >this.onPointerUp(r))</span>,this.el.addEventListener("click",<span class="fstat-no" title="function not covered" >r=</span>&gt;<span class="cstat-no" title="statement not covered" >r.preventDefault())</span>,document.addEventListener(F,<span class="fstat-no" title="function not covered" >r=</span>&gt;<span class="cstat-no" title="statement not covered" >this.onDocumentPointerDown(r))</span>,document.addEventListener(B,<span class="fstat-no" title="function not covered" >r=</span>&gt;<span class="cstat-no" title="statement not covered" >this.onDocumentPointerUp(r))</span>}<span class="fstat-no" title="function not covered" ></span>se</span>tActive(n){<span class="cstat-no" title="statement not covered" >if(this.active==n)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span></span>his.active=n,document.documentElement.classList.toggle("has-"+this.className,n),this.el.classList.toggle("active",n);l</span>et r=<span class="cstat-no" title="statement not covered" >(this.active?"to-has-":"from-has-")+this.className;<span class="cstat-no" title="statement not covered" ></span>document.documentElement.classList.add(r),setTimeout(<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >document.documentElement.classList.remove(r),</span>500)}<span class="fstat-no" title="function not covered" ></span>on</span>PointerUp(n){<span class="cstat-no" title="statement not covered" >H||(this.setActive(!0),n.preventDefault())}<span class="fstat-no" title="function not covered" ></span>on</span>DocumentPointerDown(n){<span class="cstat-no" title="statement not covered" >if(this.active){<span class="cstat-no" title="statement not covered" >if(n.target.closest(".col-menu, .tsd-filter-group"))<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span></span>his.setActive(!1)}</span>}<span class="fstat-no" title="function not covered" ></span>on</span>DocumentPointerUp(n){<span class="cstat-no" title="statement not covered" >if(!H&amp;&amp;this.active&amp;&amp;n.target.closest(".col-menu")){let r=<span class="cstat-no" title="statement not covered" >n.target.closest("a");<span class="cstat-no" title="statement not covered" ></span>if(r){let i=<span class="cstat-no" title="statement not covered" >window.location.href;<span class="cstat-no" title="statement not covered" ></span>i.indexOf("#")!=-1&amp;&amp;(i=i.substring(0,i.indexOf("#"))),r.href.substring(0,i.length)==i&amp;&amp;setTimeout(<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >this.setActive(!1),</span>250)}</span>}</span>}</span>};</span>var oe;<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >oe=localStorage}</span>catch{<span class="cstat-no" title="statement not covered" >oe={<span class="fstat-no" title="function not covered" >ge</span>tItem(){<span class="cstat-no" title="statement not covered" >return null}</span>,<span class="fstat-no" title="function not covered" >se</span>tItem(){}}}</span>v</span>ar Q=<span class="cstat-no" title="statement not covered" >oe;</span>var Le=<span class="cstat-no" title="statement not covered" >document.head.appendChild(document.createElement("style"));<span class="cstat-no" title="statement not covered" ></span>Le.dataset.for="filters";v</span>ar ee=<span class="cstat-no" title="statement not covered" >class extends k{<span class="fstat-no" title="function not covered" >co</span>nstructor(n){<span class="cstat-no" title="statement not covered" >super(n);<span class="cstat-no" title="statement not covered" >t</span>his.key=`filter-${this.el.name}`,this.value=this.el.checked,this.el.addEventListener("change",<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >this.setLocalStorage(this.el.checked)}</span>),this.setLocalStorage(this.fromLocalStorage()),Le.innerHTML+=`html:not(.${this.key}) .tsd-is-${this.el.name} { display: none; }</span></span>
`}<span class="fstat-no" title="function not covered" >fr</span>omLocalStorage(){let n=<span class="cstat-no" title="statement not covered" >Q.getItem(this.key);<span class="cstat-no" title="statement not covered" ></span>return n?n==="true":this.el.checked}<span class="fstat-no" title="function not covered" ></span>se</span>tLocalStorage(n){<span class="cstat-no" title="statement not covered" >Q.setItem(this.key,n.toString()),this.value=n,this.handleValueChange()}<span class="fstat-no" title="function not covered" ></span>ha</span>ndleValueChange(){<span class="cstat-no" title="statement not covered" >this.el.checked=this.value,document.documentElement.classList.toggle(this.key,this.value),document.querySelectorAll(".tsd-index-section").forEach(<span class="fstat-no" title="function not covered" >n=</span>&gt;{<span class="cstat-no" title="statement not covered" >n.style.display="block";l</span>et r=<span class="cstat-no" title="statement not covered" >Array.from(n.querySelectorAll(".tsd-index-link")).every(<span class="fstat-no" title="function not covered" >i=</span>&gt;<span class="cstat-no" title="statement not covered" >i.offsetParent==null)</span>;<span class="cstat-no" title="statement not covered" ></span>n.style.display=r?"none":"block"}</span>)}</span>};var te=<span class="cstat-no" title="statement not covered" >class extends k{<span class="fstat-no" title="function not covered" >co</span>nstructor(n){<span class="cstat-no" title="statement not covered" >super(n);<span class="cstat-no" title="statement not covered" >t</span>his.calculateHeights(),this.summary=this.el.querySelector(".tsd-accordion-summary"),this.icon=this.summary.querySelector("svg"),this.key=`tsd-accordion-${this.summary.textContent.replace(/\s+/g,"-").toLowerCase()}`,this.setLocalStorage(this.fromLocalStorage(),!0),this.summary.addEventListener("click",<span class="fstat-no" title="function not covered" >r=</span>&gt;<span class="cstat-no" title="statement not covered" >this.toggleVisibility(r))</span>,this.icon.style.transform=this.getIconRotation()}<span class="fstat-no" title="function not covered" ></span>ge</span>tIconRotation(n=<span class="branch-0 cbranch-no" title="branch not covered" >this.el.open)</span>{<span class="cstat-no" title="statement not covered" >return`rotate(${n?0:-90}deg)`}<span class="fstat-no" title="function not covered" ></span>ca</span>lculateHeights(){let n=<span class="cstat-no" title="statement not covered" >this.el.open,</span>{position:r,left:i}=<span class="cstat-no" title="statement not covered" >this.el.style;<span class="cstat-no" title="statement not covered" ></span>this.el.style.position="fixed",this.el.style.left="-9999px",this.el.open=!0,this.expandedHeight=this.el.offsetHeight+"px",this.el.open=!1,this.collapsedHeight=this.el.offsetHeight+"px",this.el.open=n,this.el.style.height=n?this.expandedHeight:this.collapsedHeight,this.el.style.position=r,this.el.style.left=i}<span class="fstat-no" title="function not covered" ></span>to</span>ggleVisibility(n){<span class="cstat-no" title="statement not covered" >n.preventDefault(),this.el.style.overflow="hidden",this.el.open?this.collapse():this.expand()}<span class="fstat-no" title="function not covered" ></span>ex</span>pand(n=<span class="branch-0 cbranch-no" title="branch not covered" >!0)</span>{<span class="cstat-no" title="statement not covered" >this.el.open=!0,this.animate(this.collapsedHeight,this.expandedHeight,{opening:!0,duration:n?300:0})}<span class="fstat-no" title="function not covered" ></span>co</span>llapse(n=<span class="branch-0 cbranch-no" title="branch not covered" >!0)</span>{<span class="cstat-no" title="statement not covered" >this.animate(this.expandedHeight,this.collapsedHeight,{opening:!1,duration:n?300:0})}<span class="fstat-no" title="function not covered" ></span>an</span>imate(n,r,{opening:i,duration:s=<span class="branch-0 cbranch-no" title="branch not covered" >300}</span>){<span class="cstat-no" title="statement not covered" >if(this.animation)<span class="cstat-no" title="statement not covered" >return;l</span></span>et o=<span class="cstat-no" title="statement not covered" >{duration:s,easing:"ease"};<span class="cstat-no" title="statement not covered" ></span>this.animation=this.el.animate({height:[n,r]},o),this.icon.animate({transform:[this.icon.style.transform||this.getIconRotation(!i),this.getIconRotation(i)]},o).addEventListener("finish",<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >this.icon.style.transform=this.getIconRotation(i)}</span>),this.animation.addEventListener("finish",<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >this.animationEnd(i))</span>}<span class="fstat-no" title="function not covered" ></span>an</span>imationEnd(n){<span class="cstat-no" title="statement not covered" >this.el.open=n,this.animation=void 0,this.el.style.height="auto",this.el.style.overflow="visible",this.setLocalStorage(n)}<span class="fstat-no" title="function not covered" ></span>fr</span>omLocalStorage(){let n=<span class="cstat-no" title="statement not covered" >Q.getItem(this.key);<span class="cstat-no" title="statement not covered" ></span>return n?n==="true":this.el.open}<span class="fstat-no" title="function not covered" ></span>se</span>tLocalStorage(n,r=<span class="branch-0 cbranch-no" title="branch not covered" >!1)</span>{<span class="cstat-no" title="statement not covered" >this.fromLocalStorage()===n&amp;&amp;!r||(Q.setItem(this.key,n.toString()),this.el.open=n,this.handleValueChange(r))}<span class="fstat-no" title="function not covered" ></span>ha</span>ndleValueChange(n=<span class="branch-0 cbranch-no" title="branch not covered" >!1)</span>{<span class="cstat-no" title="statement not covered" >this.fromLocalStorage()===this.el.open&amp;&amp;!n||(this.fromLocalStorage()?this.expand(!1):this.collapse(!1))}</span>};</span>function <span class="fstat-no" title="function not covered" >be(</span>t){let e=<span class="cstat-no" title="statement not covered" >Q.getItem("tsd-theme")||"os";<span class="cstat-no" title="statement not covered" ></span>t.value=e,Ee(e),t.addEventListener("change",<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >Q.setItem("tsd-theme",t.value),Ee(t.value)}</span>)}</span>function <span class="fstat-no" title="function not covered" >Ee(</span>t){<span class="cstat-no" title="statement not covered" >document.documentElement.dataset.theme=t}<span class="cstat-no" title="statement not covered" ></span>ve();<span class="cstat-no" title="statement not covered" >j</span>(X,".menu-highlight");<span class="cstat-no" title="statement not covered" >j</span>(K,"a[data-toggle]");<span class="cstat-no" title="statement not covered" >j</span>(te,".tsd-index-accordion");<span class="cstat-no" title="statement not covered" >j</span>(ee,".tsd-filter-item input[type=checkbox]");v</span>ar Se=<span class="cstat-no" title="statement not covered" >document.getElementById("theme");<span class="cstat-no" title="statement not covered" ></span>Se&amp;&amp;be(Se);v</span>ar Be=<span class="cstat-no" title="statement not covered" >new Y;<span class="cstat-no" title="statement not covered" ></span>Object.defineProperty(window,"app",{value:Be});}</span>)();
/*!
 * lunr.Builder
 * Copyright (C) 2020 Oliver Nightingale
 */
/*!
 * lunr.Index
 * Copyright (C) 2020 Oliver Nightingale
 */
/*!
 * lunr.Pipeline
 * Copyright (C) 2020 Oliver Nightingale
 */
/*!
 * lunr.Set
 * Copyright (C) 2020 Oliver Nightingale
 */
/*!
 * lunr.TokenSet
 * Copyright (C) 2020 Oliver Nightingale
 */
/*!
 * lunr.Vector
 * Copyright (C) 2020 Oliver Nightingale
 */
/*!
 * lunr.stemmer
 * Copyright (C) 2020 Oliver Nightingale
 * Includes code from - http://tartarus.org/~martin/PorterStemmer/js.txt
 */
/*!
 * lunr.stopWordFilter
 * Copyright (C) 2020 Oliver Nightingale
 */
/*!
 * lunr.tokenizer
 * Copyright (C) 2020 Oliver Nightingale
 */
/*!
 * lunr.trimmer
 * Copyright (C) 2020 Oliver Nightingale
 */
/*!
 * lunr.utils
 * Copyright (C) 2020 Oliver Nightingale
 */
/**
 * lunr - http://lunrjs.com - A bit like Solr, but much smaller and not as bright - 2.3.9
 * Copyright (C) 2020 Oliver Nightingale
 * @license MIT
 */
&nbsp;</pre></td></tr></table></pre>

                <div class='push'></div><!-- for sticky footer -->
            </div><!-- /wrapper -->
            <div class='footer quiet pad2 space-top1 center small'>
                Code coverage generated by
                <a href="https://istanbul.js.org/" target="_blank">istanbul</a>
                at Fri Oct 07 2022 15:07:26 GMT+0200 (Mitteleuropäische Sommerzeit)
            </div>
        </div>
        <script src="../../prettify.js"></script>
        <script>
            window.onload = function () {
                prettyPrint();
            };
        </script>
        <script src="../../sorter.js"></script>
        <script src="../../block-navigation.js"></script>
    </body>
</html>
    